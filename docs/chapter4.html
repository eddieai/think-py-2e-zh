
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第四章 案例学习：交互设计 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter5.html" />
    
    
    <link rel="prev" href="chapter3.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="chapter1.html">
            
                <a href="chapter1.html">
            
                    
                    第一章 编程之路
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="chapter2.html">
            
                <a href="chapter2.html">
            
                    
                    第二章 变量，表达式，语句
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="chapter3.html">
            
                <a href="chapter3.html">
            
                    
                    第三章 函数
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.5" data-path="chapter4.html">
            
                <a href="chapter4.html">
            
                    
                    第四章 案例学习：交互设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="chapter5.html">
            
                <a href="chapter5.html">
            
                    
                    第五章 条件循环
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="chapter6.html">
            
                <a href="chapter6.html">
            
                    
                    第六章 有返回值的函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="chapter7.html">
            
                <a href="chapter7.html">
            
                    
                    第七章 迭代
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="chapter8.html">
            
                <a href="chapter8.html">
            
                    
                    第八章 字符串
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="chapter9.html">
            
                <a href="chapter9.html">
            
                    
                    第九章 案例学习：单词游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="chapter10.html">
            
                <a href="chapter10.html">
            
                    
                    第十章 列表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="chapter11.html">
            
                <a href="chapter11.html">
            
                    
                    第十一章 字典
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="chapter12.html">
            
                <a href="chapter12.html">
            
                    
                    第十二章 元组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="chapter13.html">
            
                <a href="chapter13.html">
            
                    
                    第十三章 案例学习：数据结构的选择
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="chapter14.html">
            
                <a href="chapter14.html">
            
                    
                    第十四章 文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="chapter15.html">
            
                <a href="chapter15.html">
            
                    
                    第十五章 类和对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="chapter16.html">
            
                <a href="chapter16.html">
            
                    
                    第十六章 类和函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="chapter17.html">
            
                <a href="chapter17.html">
            
                    
                    第十七章 类和方法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="chapter18.html">
            
                <a href="chapter18.html">
            
                    
                    第十八章 继承
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="chapter19.html">
            
                <a href="chapter19.html">
            
                    
                    第十九章 更多功能
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第四章 案例学习：交互设计</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第四章--案例学习：交互设计">第四章  案例学习：交互设计</h1>
<p>本章会提供一个案例，用于展示如何却设计一些共同工作的函数。</p>
<p>本章介绍了小乌龟这个模块，这允许你用小龟的图形功能来制作一些图形。乌龟模块在大部分的 Python 中都有安装，不过如果你在线使用 PythnAnywhere，你就无法运行这些乌龟样例了（至少我写这本教材的时候还不行）。</p>
<p>（译者注：都学到第四章了，你还不本地安装个 Python 也太说不过去了吧。）</p>
<p>如果你已经安装了 Python 在你的电脑上，你就能运行这些例子了。没安装的话呢，这就是安装的好时机了呗。我已经把相关介绍放到网页上面了，<a href="http://tinyurl.com/thinkpython2e" target="_blank">点击访问</a>。</p>
<p>本章代码样例可以点击<a href="http://thinkpython2.com/code/polygon.py" target="_blank">此链接</a>来下载了。</p>
<h2 id="41--乌龟模块">4.1  乌龟模块</h2>
<p>要检查你是不是已经安装了这个乌龟模块，你要打开 Python 解释器来输入如下内容：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> turtle 
<span class="hljs-meta">&gt;&gt;&gt; </span>bob = turtle.Turtle()
</code></pre>
<p>运行上述例子的时候，应该就能新建一个小窗口，还有个小箭头象征小乌龟。如果有的话就对了，把窗口关掉吧先。</p>
<p>建立一个叫做 mypolygon.py 的文件，在里面输入如下内容：</p>
<pre><code class="lang-py"><span class="hljs-keyword">import</span> turtle 
bob = turtle.Turtle() 
<span class="hljs-built_in">print</span>(bob) 
turtle.mainloop()
</code></pre>
<p>这个小乌龟模块（记着是小写的 t）提供了一个叫做 Turtle（注意这里是大写的，大小写要去分！）的函数，这个函数会创建一个 Turtle 对象，我们把它赋值给 bob 这个变量。打印一下 bob 就能显示如下内容：</p>
<pre><code class="lang-Bash">&lt;turtle.Turtle object at 0xb7bfbf4c&gt;
</code></pre>
<p>这就意味着 bob 已经指向了模块 turtle 中所定义的 Turtle 类的一个对象。</p>
<p>mainloop 这个函数是告诉窗口等用户来做些事情，当然本次尝试的情况下用户也就是关闭窗口而已了。</p>
<p>一旦你创建了一个 Trutle，你就可以调用一些方法让他在窗口中移动。方法跟函数有点相似，但语法的使用稍微不太一样。比如你可以让小乌龟往前走：</p>
<pre><code class="lang-py">bob.fd(<span class="hljs-number">100</span>)
</code></pre>
<p>fd 这个方法，是 turtle 类这个叫做 bob 的对象所包含的。调用这个方法就像是做出一个请求一样：你再让 bob 向前移动。fd 这个方法的参数是像素数距离，所以实际的大小依赖于你显示器的情况了。</p>
<p>Turtle 对象中还有一些其他方法，比如 bk 是后退，lt 是左转，rt 是右转。lt 和 rt 用偏转角度做参数。</p>
<p>另外，每个 Turtle 都相当于带着笔，可以落下或者抬起；如果笔落下了，Turtle 移动的时候就会留下轨迹了。抬笔落笔的方法缩写粉笔嗯是 pu 和 pd。</p>
<p>画一个直角，就要把下面这些线加到程序里面（当然要先创建一个 bob 并且在此之前运行 mainloop）：</p>
<pre><code class="lang-py">bob.fd(<span class="hljs-number">100</span>) 
bob.lt(<span class="hljs-number">90</span>) 
bob.fd(<span class="hljs-number">100</span>)
</code></pre>
<p>运行这个程序，你就能看到 bob 先向东再往北，后面就留下了两根互相垂直的线段了。</p>
<p>现在修改一下程序，去画一个正方形。这个程序运行不好的话就不要继续后面的章节！</p>
<h2 id="42--简单的重复">4.2  简单的重复</h2>
<p>你估计会写出如下的内容：</p>
<pre><code class="lang-py">bob.fd(<span class="hljs-number">100</span>) 
bob.lt(<span class="hljs-number">90</span>)  
bob.fd(<span class="hljs-number">100</span>) 
bob.lt(<span class="hljs-number">90</span>)  
bob.fd(<span class="hljs-number">100</span>) 
bob.lt(<span class="hljs-number">90</span>)  
bob.fd(<span class="hljs-number">100</span>)
</code></pre>
<p>上面这个太麻烦了，咱们可以用一个 for 语句来让这个过程更简洁。把下面的代码添加到 mypolygon.py 中然后运行一下：</p>
<pre><code class="lang-py"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):     
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Hello!'</span>)
</code></pre>
<p>你将会看到这样的输出：</p>
<pre><code class="lang-Bash">Hello! 
Hello! 
Hello! 
Hello!
</code></pre>
<p>这就是 for 语句的最简单的一种应用；以后我们会看到更多。不过当前这种简单的足够你来重构一下你的正方形绘制程序了。不达目的不罢休，不要跳过困难哈，一定要编写出来这个再进行后面的内容。</p>
<p>这就是一个用 for 语句来画正方形的语句：</p>
<pre><code class="lang-py"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):     
    bob.fd(<span class="hljs-number">100</span>)     
    bob.lt(<span class="hljs-number">90</span>)
</code></pre>
<p>for 语句的语法跟函数定义有点相似。有一个头部，头部的结尾要用冒号，然后还有一个缩进的循环体。循环体可以包含任意多的语句。</p>
<p>for 语句也被叫做循环，因为运行流程会重复执行循环体。在本节的例子中，循环进行了四次。</p>
<p>这次的正方形绘制代码实际上和之前的少有不同了，因为在画完了最后一个边之后，多了一次转向。多出来的这部分需要消耗额外的时间，但简化了下次我们来循环进行绘制的过程。这个版本的代码也有一个额外的效果：让小乌龟回到起点，朝着初始方向。</p>
<h2 id="43--练习">4.3  练习</h2>
<p>下面是一系列使用 TurtleWorld 的练习。主要就是比较有意思，不过也有一些训练的作用。你做这些练习的时候，一定要注意考虑这些训练的作用。</p>
<p>练习后面是有一些样例的解决方案的，所以你要做完了再往后看，至少你得试试，不会做了看看答案也行哈。</p>
<p>1.写一个函数叫做 square（译者注：就是正方形的意思），有一个名叫 t 的参数，这个 t 是一个 turtle。用这个 turtle 来画一个正方形。写一个函数调用，把 bob 作为参数传递给 square，然后再运行这个程序。</p>
<p>2.给这个 square 函数再加一个参数，叫做 length（译者注：长度）。把函数体修改一下，让长度 length 赋值给各个边的长度，然后修改一下调用函数的代码，再提供一个这个对应长度的参数。再次运行一下，用一系列不同的长度值来测试一下你的程序。</p>
<p>3.复制一下 square 这个函数，把名字改成 polygon（译者注：意思为多边形）。另外添加一个参数叫做 n，然后修改函数体，让函数实现画一个正 n 边的多边形。提示：正 n 多边形的外角为 360/n 度。</p>
<p>4.在写一个叫做 circle（译者注：圆）的函数，也用一个 turtle 类的对象 t，以及一个半径 r，作为参数，画一个近似的圆，通过调用 polygon 函数来近似实现，用适当的边长和边数。用不同的半径值来测试一下你的函数。</p>
<p>提示：算出圆的周长，确保边长乘以边数的值（近似）等于圆周长。</p>
<p>5.在 circle 基础上做一个叫做 arc 的函数，在 circle 的基础上添加一个 angle（译者注：角度）变量，用这个角度值来确定画多大的一个圆弧。用度做单位，当 angle 等于 360 度的时候，arc 函数就应当画出一个整团了。</p>
<h2 id="44--封装">4.4  封装</h2>
<p>第一个练习让你把正方形绘制的代码定义到一个函数里面，然后调用这个函数，传入一个 turtle 对象作为参数。下面就是个例子了：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">t</span>):     
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):         
        t.fd(<span class="hljs-number">100</span>)         
        t.lt(<span class="hljs-number">90</span>)  
square(bob)
</code></pre>
<p>在最内部的语句里面，fd 和 lt 缩进了两次，这个意思是他们是 for 循环的循环体内部成员，而 for 循环本身缩进了一次，说明 for 语句被包含在函数的定义当中。接下来的那行 square(bob)，紧靠左侧，没有缩进，这说明 for 循环和函数定义都结束了。</p>
<p>在函数体内部，t 所指代的就是小乌龟 bob，因此让 t 来左转九十度的效果完全等同于让 bob 来左转九十度。本文中没有把形式参数的名字设置成 bob，这是为啥呢？是因为用 t 可以指代任意一个小乌龟，不仅仅是 bob，所以你就能再创建另一个小乌龟，把它传递给 square 这个函数作为实际参数：</p>
<pre><code class="lang-py">alice = Turtle() 
square(alice)
</code></pre>
<p>用函数的形式把一段代码包装起来，叫做封装。这样有一个好处，就是给代码起了个名字，有类似文档说明的功能，更好理解了。另外一个好处是下次重复使用这段代码的时候，再次调用函数就可以了，这比复制粘贴函数体可方便多了。</p>
<h2 id="45--泛化">4.5  泛化</h2>
<p>下一步就是给 square 函数添加一个长度参数了。下面是样例：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">t, length</span>):     
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):         
        t.fd(length)         
        t.lt(<span class="hljs-number">90</span>)  
square(bob, <span class="hljs-number">100</span>)
</code></pre>
<p>给函数添加参数，就叫做泛化，因为者可以让函数的功能更广泛：在之前的版本中，square 这个函数画出来的正方形总是一个尺寸的；在这个新版本里面，可以自定义边长了。</p>
<p>下一步也还是泛化。这次就是不光要画正方形了，要画一个多边形，可以指定边数的。下面是样例：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">polygon</span>(<span class="hljs-params">t, n, length</span>):    
    angle = <span class="hljs-number">360</span> / n     
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):         
        t.fd(length)         
        t.lt(angle)  
polygon(bob, <span class="hljs-number">7</span>, <span class="hljs-number">70</span>)
</code></pre>
<p>这个例子画了一个每个边长度都为 70 像素的七边形。</p>
<p>如果你用 Python2 的话，角度可能因为整除而导致的偏差。简单的解决方法就是用 360.0 来除以 n 而不是用 360，这就是用浮点数替代了原来的整形，结果就是一个浮点数了。</p>
<p>当一个函数有超过一个数据参数的时候，很容易忘掉这些参数都是什么，或者忘掉他们的顺序。为了避免这个情况，可以把形式参数的名字包含在一个实际参数列表中：</p>
<pre><code class="lang-py">polygon(bob, n=<span class="hljs-number">7</span>, length=<span class="hljs-number">70</span>)
</code></pre>
<p>这些列表叫做关键参数列表，因为他们把形式参数的名字作为关键词包含了进来。（注意区别这里的关键词可不是 Python 语言的关键词哈！这里就是字面意思，很关键的词。）</p>
<p>这种语法结构让程序更容易被人读懂。也能提醒实际参数和形式参数的使用过程：调用一个函数的时候，把实际参数的值赋给了形式参数。</p>
<h2 id="46--接口设计">4.6  接口设计</h2>
<p>下一步就是写 circle 这个函数了，需要半径 r 作为一个参数。下面是一个简单的样例，使用 polygon 函数来画一个 50 边形，来接近一个圆：</p>
<pre><code class="lang-py"><span class="hljs-keyword">import</span> math  
<span class="hljs-keyword">def</span> <span class="hljs-title function_">circle</span>(<span class="hljs-params">t, r</span>):     
    circumference = <span class="hljs-number">2</span> * math.pi * r    
    n = <span class="hljs-number">50</span>     
    length = circumference / n     
    polygon(t, n, length)
</code></pre>
<p>第一行计算了圆的周长，使用 2 乘以圆周率再乘以半径 r。这个计算用到了圆周率，所以要导入 math 模块。通常都要把导入语句放到整个脚本的开头。</p>
<p>n 是我们用来逼近一个圆所用的线段数量，所以 length 就是每一个线段的长度了。polygon 画一个 50 边的多边形，来近似做一个半径为 r 的圆。</p>
<p>这种方案的一个局限性就是 n 是常数，就意味着对于一些大尺寸的圆，线段数目就太多了，而对小的圆，又浪费了很多小线段。解决的方法就是进一步扩展函数，让函数把 n 也作为一个参数。这就亏让用户（调用 circle 函数的任何人）有更多决定权，可以控制所用的线段数量，当然，接口就不那么简洁了。</p>
<p>函数的接口就是关于它如何工作的一个概述：都有什么变量？函数实现什么功能？以及返回值是什么？允许调用者随意操作而不用处理一些无关紧要的细节，这种函数接口就是简洁的。</p>
<p>在本节的例子中，r 包含于接口内，因为要用它来确定所画圆的大小。n 就不那么合适了，因为它是用来处理如何具体绘制一个圆的。</p>
<p>与其让接口复杂冗余，更好的思路是让 n 根据周长来自适应一个合适的值：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">circle</span>(<span class="hljs-params">t, r</span>):     
    circumference = <span class="hljs-number">2</span> * math.pi * r     
    n = <span class="hljs-built_in">int</span>(circumference / <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>     
    length = circumference / n     
    polygon(t, n, length)
</code></pre>
<p>现在线段个数就是周长的三分之一了，因此每段线段的长度近似为 3，这个大小可以让圆看着不错，也对任意大小的圆都适用了。</p>
<h2 id="47--重构">4.7  重构</h2>
<p>当我写 circle 这个函数的时候，我能利用多边形函数 polygon 是因为一个足够多边的多边形和圆很接近。但圆弧就不太适合这个思路了；我们不能用多边形或者圆来画一个圆弧。</p>
<p>一个替代的方法就是把 polygon 修改一下，转换成圆弧。结果大概如下所示：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">arc</span>(<span class="hljs-params">t, r, angle</span>):     
    arc_length = <span class="hljs-number">2</span> * math.pi * r * angle / <span class="hljs-number">360</span>     
    n = <span class="hljs-built_in">int</span>(arc_length / <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>     
    step_length = arc_length / n     
    step_angle = angle / n          
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        
        t.fd(step_length)         
        t.lt(step_angle)
</code></pre>
<p>这个函数的后半段看着和多边形那个还挺像的，但必须修改一下接口才能重利用多边形的代码。我们在多边形函数上增加 angle（角度）作为第三个参数，但继续叫多边形就不太合适了，因为不闭合啊！所以就改名叫它多段线 polyline：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">polyline</span>(<span class="hljs-params">t, n, length, angle</span>):     
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):         
    t.fd(length)         
    t.lt(angle)
</code></pre>
<p>现在就可以用多段线 polyline 来重写多边形 polygon 和圆弧 arc：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">polygon</span>(<span class="hljs-params">t, n, length</span>):     
    angle = <span class="hljs-number">360.0</span> / n     
    polyline(t, n, length, angle)  
<span class="hljs-keyword">def</span> <span class="hljs-title function_">arc</span>(<span class="hljs-params">t, r, angle</span>):     
    arc_length = <span class="hljs-number">2</span> * math.pi * r * angle / <span class="hljs-number">360</span>     
    n = <span class="hljs-built_in">int</span>(arc_length / <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>     
    step_length = arc_length / n     
    step_angle = <span class="hljs-built_in">float</span>(angle) / n     
    polyline(t, n, step_length, step_angle)
</code></pre>
<p>最终，咱们就可以用圆弧 arc 来重写 circle 的实现了：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">circle</span>(<span class="hljs-params">t, r</span>):     
    arc(t, r, <span class="hljs-number">360</span>)
</code></pre>
<p>这个过程中，改进了接口设计，增强了代码再利用，这就叫做重构。在本节的这个例子中，我们先是注意到圆弧 arc 和多边形 polygon 有相似的代码，所以我们把他们都用多段线 polyline 来实现。</p>
<p>如果我们事先进行了计划，估计就会先写出多段线函数 polyline，然后就不用重构了，但大家在开始一个项目之前往往不一定了解的那么清楚。一旦开始编码了，你就逐渐更理解其中的问题了。有时候重构就意味着你已经学到了新的内容了。</p>
<h2 id="48--开发计划">4.8  开发计划</h2>
<p>开发计划是写程序的一系列过程。我们本章所用的就是『封装-泛化』的模式。这一过程的步骤如下：</p>
<ol>
<li><p>开始写一个特别小的程序，没有函数定义。</p>
</li>
<li><p>一旦有你的程序能用了，确定一下实现功能的这部分有练习的语句，封装成函数，并命名一下。</p>
</li>
<li><p>通过逐步给这个函数增加参数的方式来泛化。</p>
</li>
<li><p>重复 1-3 步骤，一直到你有了一系列能工作的函数为止。把函数复制粘贴出来，避免重复输入或者修改了。</p>
</li>
<li><p>看看是不是有通过重构来改进函数的可能。比如，假设你在一些地方看到了相似的代码，就可以把这部分代码做成一个函数。</p>
</li>
</ol>
<p>这个模式有一些缺点，我们后续会看到一些替代的方式，但这个模式是很有用的，尤其对耐饿实现不值得怎么去把程序分成多个函数的情况。</p>
<h2 id="49--文档字符串">4.9  文档字符串</h2>
<p>文档字符串是指：在函数开头部位，解释函数的交互接口的字符串，doc 是文档 documentation 的缩写。下面是一个例子：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">polyline</span>(<span class="hljs-params">t, n, length, angle</span>):     
<span class="hljs-string">"""
Draws n line segments with the given length and     angle (in degrees) between them. 
t is a turtle.     """</span>         
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):         
        t.fd(length)         
        t.lt(angle)
</code></pre>
<p>一般情况下，所有文档字符串都是三重引用字符串，也被叫做多行字符串，因为三重的单引号表示允许这个字符串是多行的。</p>
<p>这些文字很简洁，但都包含了一些关键的信息，这些信息对于函数使用者来说至关重要。这些信息简要解释了函数的用途（不会说细节，也不会说如何实现）。文档解释了每个参数对函数行为的影响，以及各自的类型（一般在不是显而易见的情况下就给解释了）。</p>
<p>写这种文档，对交互接口的设计来说，是至关重要的。设计良好的交互接口应该很容易解释明白；如果你的函数有一个特别不好解释了，估计这个函数的交互设计还存在需要改进的地方。</p>
<h2 id="410--调试">4.10  调试</h2>
<p>一个交互接口，就像是函数和调用者的一个中间人。调用者提供特定的参数，函数完成特定的任务。</p>
<p>例如，polyline 这个多段线函数，需要四个实际参数：t 必须是一个 Turtle 小乌龟；n（边数）必须是一个整形；length（长度）应该是一个正数；angle（角度）必须是一个以度为单位的角度值。</p>
<p>这些要求叫做『前置条件』，因为要在函数开始运行之前就要实现才行。相应的在函数的结尾那里的条件叫『后置条件』。后置条件包含函数的预期效果（如画线段）和其他作用（如移动海龟或进行其他改动）。</p>
<p>前置条件是准备给函数调用者的。如果调用者违背了（妥当标注的）前置条件，然后函数不能正常工作，这个 bug 就会反馈在函数调用者上，而不是函数本身。</p>
<p>如果前置条件得到了满足，而后置条件未能满足，这个 bug 就是函数的了。所以如果你的前后置条件都弄清晰，对调试很有帮助。</p>
<h2 id="411--glossary-术语列表">4.11  Glossary 术语列表</h2>
<p>method:
A function that is associated with an object and called using dot notation.</p>
<blockquote>
<p>方法：某个类中一个对象所具有的函数，用点连接来进行调用。</p>
</blockquote>
<p>loop:
A part of a program that can run repeatedly.</p>
<blockquote>
<p>循环：程序中重复运行的一部分。</p>
</blockquote>
<p>encapsulation:
The process of transforming a sequence of statements into a function definition.</p>
<blockquote>
<p>封装：把一系列相关的语句整理定义成一个函数的过程。</p>
</blockquote>
<p>generalization:
The process of replacing something unnecessarily specific (like a number) with something appropriately general (like a variable or parameter).</p>
<blockquote>
<p>泛化：把一些不必要的内容用更广泛通用的内容来替换掉的过程，比如把一个数字替换成了一个变量或者参数。</p>
</blockquote>
<p>keyword argument:
An argument that includes the name of the parameter as a “keyword”.</p>
<blockquote>
<p>关键词参数：一种特殊的实际参数，把形式参数的名字作为关键词包含在内。</p>
</blockquote>
<p>interface:
A description of how to use a function, including the name and descriptions of the arguments and return value.</p>
<blockquote>
<p>交互接口：对如何使用一个函数的描述，包括了函数名，以及对实际参数和返回值的描述。</p>
</blockquote>
<p>refactoring:
The process of modifying a working program to improve function interfaces and other qualities of the code.</p>
<blockquote>
<p>重构：对一份能工作的程序进行修改，改进函数交互接口以及提高代码其他方面质量的过程。</p>
</blockquote>
<p>development plan:
A process for writing programs.</p>
<blockquote>
<p>开发计划：写程序的过程。</p>
</blockquote>
<p>docstring:
A string that appears at the top of a function definition to document the function’s interface.</p>
<blockquote>
<p>文档字符串：一个在函数定义的顶部的字符串，讲解函数的交互接口。</p>
</blockquote>
<p>precondition:
A requirement that should be satisfied by the caller before a function starts.</p>
<blockquote>
<p>前置条件：函数开始之前，调用者应当满足的要求。</p>
</blockquote>
<p>postcondition:
A requirement that should be satisfied by the function before it ends.</p>
<blockquote>
<p>后置条件：函数结束之前应该满足的一些要求。</p>
</blockquote>
<h2 id="412--练习">4.12  练习</h2>
<h3 id="练习-1">练习 1</h3>
<p>点击下面这个链接<a href="http://thinkpython2.com/code/polygon.py" target="_blank">下载代码</a>。</p>
<ol>
<li><p>画一个栈图，表明运行函数 circle(bob,radius)时候程序的状态。你可以手算一下，或者把输出语句加到代码上。</p>
</li>
<li><p>4.7 小节中的那个版本的 arc 函数并不太精确，因为对圆进行线性逼近总会超过真实情况。结果就是小乌龟总会距离正确位置偏离一些像素。我的样例给出了一种降低这种误差程度的方法。阅读一下代码，看你能不能理解。如果你画一个图标，也许就能明白代码是怎么工作的了。</p>
</li>
</ol>
<hr></hr>
<p> <img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPythonExercise4.2.png" alt="Turtle flowers"></img>
Figure 4.1: Turtle flowers.</p>
<hr></hr>
<h3 id="练习-2">练习 2</h3>
<p>写一系列的合适的函数组合，画出图 4.1 所示的花图案。</p>
<p><a href="http://thinkpython2.com/code/flower.py" target="_blank">样例</a> 
<a href="http://thinkpython2.com/code/polygon.py" target="_blank">以及此链接文件</a></p>
<hr></hr>
<p><img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPythonExercise4.3.png" alt="Turtle pies"></img>
Figure 4.2: Turtle pies.</p>
<hr></hr>
<h3 id="练习-3">练习 3</h3>
<p>写一系列的合适的函数组合，画出图 4.2 所示的形状。</p>
<p><a href="http://thinkpython2.com/code/pie.py" target="_blank">样例</a></p>
<h3 id="练习-4">练习 4</h3>
<p>字母表当中的字母都可以用一定数量的基本元素来构建，比如竖直或者水平的线条，以及一些曲线。设计一个能用最小数量的基本元素画出来的字母表，然后写个函数来画字母出来。</p>
<p>你应当为没一个字母写一个函数，名字就比如 draw_a,draw_b 等等，然后把你的函数放到一个叫做 letters.py 的文件中。你可以从这个<a href="http://thinkpython2.com/code/typewriter.py" target="_blank">链接</a> 下载一个乌龟打字机来帮你检测一下代码。</p>
<p>你可以参考这里的<a href="http://thinkpython2.com/code/letters.py" target="_blank">样例</a>;同时还需要<a href="http://thinkpython2.com/code/polygon.py" target="_blank">这些</a>。</p>
<h2 id="练习-5">练习 5</h2>
<p>去<a href="http://en.wikipedia.org/wiki/Spiral" target="_blank">Wiki 百科</a>看一下螺旋线的相关内容;然后写个程序来画阿基米德曲线（曲线中的一种）。<a href="http://thinkpython2.com/code/spiral.py" target="_blank">样例</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter3.html" class="navigation navigation-prev " aria-label="Previous page: 第三章 函数">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter5.html" class="navigation navigation-next " aria-label="Next page: 第五章 条件循环">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第四章 案例学习：交互设计","level":"1.5","depth":1,"next":{"title":"第五章 条件循环","level":"1.6","depth":1,"path":"chapter5.md","ref":"chapter5.md","articles":[]},"previous":{"title":"第三章 函数","level":"1.4","depth":1,"path":"chapter3.md","ref":"chapter3.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapter4.md","mtime":"2024-08-23T09:01:53.770Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-23T09:11:00.343Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

