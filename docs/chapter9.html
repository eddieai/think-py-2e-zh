
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第九章 案例学习：单词游戏 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter10.html" />
    
    
    <link rel="prev" href="chapter8.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="chapter1.html">
            
                <a href="chapter1.html">
            
                    
                    第一章 编程之路
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="chapter2.html">
            
                <a href="chapter2.html">
            
                    
                    第二章 变量，表达式，语句
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="chapter3.html">
            
                <a href="chapter3.html">
            
                    
                    第三章 函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="chapter4.html">
            
                <a href="chapter4.html">
            
                    
                    第四章 案例学习：交互设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="chapter5.html">
            
                <a href="chapter5.html">
            
                    
                    第五章 条件循环
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="chapter6.html">
            
                <a href="chapter6.html">
            
                    
                    第六章 有返回值的函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="chapter7.html">
            
                <a href="chapter7.html">
            
                    
                    第七章 迭代
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="chapter8.html">
            
                <a href="chapter8.html">
            
                    
                    第八章 字符串
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.10" data-path="chapter9.html">
            
                <a href="chapter9.html">
            
                    
                    第九章 案例学习：单词游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="chapter10.html">
            
                <a href="chapter10.html">
            
                    
                    第十章 列表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="chapter11.html">
            
                <a href="chapter11.html">
            
                    
                    第十一章 字典
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="chapter12.html">
            
                <a href="chapter12.html">
            
                    
                    第十二章 元组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="chapter13.html">
            
                <a href="chapter13.html">
            
                    
                    第十三章 案例学习：数据结构的选择
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="chapter14.html">
            
                <a href="chapter14.html">
            
                    
                    第十四章 文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="chapter15.html">
            
                <a href="chapter15.html">
            
                    
                    第十五章 类和对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="chapter16.html">
            
                <a href="chapter16.html">
            
                    
                    第十六章 类和函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="chapter17.html">
            
                <a href="chapter17.html">
            
                    
                    第十七章 类和方法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="chapter18.html">
            
                <a href="chapter18.html">
            
                    
                    第十八章 继承
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="chapter19.html">
            
                <a href="chapter19.html">
            
                    
                    第十九章 更多功能
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第九章 案例学习：单词游戏</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第九章--案例学习：单词游戏">第九章  案例学习：单词游戏</h1>
<p>本章我们进行第二个案例学习，这一案例中涉及到了用搜索具有某些特征的单词来猜谜。比如，我们会发现英语中最长的回文词，然后搜索那些按照单词表顺序排列字母的单词。我还会给出一种新的程序开发计划：降低问题的复杂性和难度，还原到以前解决的问题。</p>
<h2 id="91--读取字符列表">9.1  读取字符列表</h2>
<p>本章练习中，咱们需要用一个英语词汇列表。网上有很多，不过最适合我们的列表并且是共有领域的，莫过于 Grady Ward 这份词汇表，这是 Moby 词典计划的一部分（点击<a href="http://wikipedia.org/wiki/Moby_Project" target="_blank">此链接访问详情</a>）。这是一份 113，809 个公认的字谜表；也就是公认可以用于字谜游戏以及其他文字游戏的单词。在 Moby 的词汇项目中，该词表的文件名为 113809of.fic；你可以下载一份副本，这里名字简化成 words.txt 了，下载地址<a href="http://thinkpython2.com/code/words.txt" target="_blank">在这里</a>。</p>
<p>这个文件就是纯文本，所以你可以用文本编辑器打开一下，不过也可以用 Python 来读取。Python 内置了一个叫 open 的函数，接收文件名做参数，返回一个文件对象，你可以用它来读取文件。</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fin = <span class="hljs-built_in">open</span>(<span class="hljs-string">'words.txt'</span>)
</code></pre>
<p>fin 是一个用来表示输入的文件的常用名字。这个文件对象提供了好几种读取的方法，包括逐行读取，这种方法是读取文本中的一整行直到结尾，然后把读取的内容作为字符串返回：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fin.readline()
<span class="hljs-string">'aa\r\n'</span>
</code></pre>
<p>这一列当中的第一个词就是『aa』了，这是一种<strong>熔岩</strong>（译者注：“aa”是夏威夷词汇，音“阿阿”，用来描述表面粗糙的熔岩流。译者本人就是地学专业的，都很少接触这个词，本教材作者真博学啊）。后面跟着的\r\n 的意思代表着有两个转义字符，一个是回车，一个是换行，这样把这个单词从下一个单词分隔开来。</p>
<p>文件对象会记录这个单词在源文件中的位置，所以下次你再调用 readline 的时候，就能得到下一个词了：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fin.readline()
<span class="hljs-string">'aah\r\n'</span>
</code></pre>
<p>下一个词是『aah』，这完全是一个正规的词汇，不要怪异眼神看我哦。另外如果转义字符让你很烦，咱们可以稍加修改来去掉它，用字符串的 strip 方法即可：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>line = fin.readline()
<span class="hljs-meta">&gt;&gt;&gt; </span>word = line.strip()
<span class="hljs-meta">&gt;&gt;&gt; </span>word
<span class="hljs-string">'aahed'</span>
</code></pre>
<p>在 for 循环中也可以使用文件对象。下面的这个程序读取整个 words.txt 文件，然后每行输出一个词：</p>
<pre><code class="lang-py">fin = <span class="hljs-built_in">open</span>(<span class="hljs-string">'words.txt'</span>)
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fin:
        word = line.strip()
        <span class="hljs-built_in">print</span>(word)
</code></pre>
<h2 id="92--练习">9.2  练习</h2>
<p>下面这些练习都有样例代码。不过你最好在看答案之前先自己对每个练习都尝试一下。</p>
<h3 id="练习-1">练习 1</h3>
<p>写一个程序读取 words.txt，然后只输出超过 20 个字母长度的词（这个长度不包括转义字符）。</p>
<h3 id="练习-2">练习 2</h3>
<p>在 1939 年，作家厄尔尼斯特·文森特·莱特曾经写过一篇 5 万字的小说《葛士比》，里面没有一个字母 e。因为在英语中 e 是用的次数最多的字母，所以这很不容易的。事实上，不使用最常见的字符，都很难想出一个简单的想法。一开始很慢，不过仔细一些，经过几个小时的训练之后，你就逐渐能做到了。</p>
<p>好了，我不扯淡了。 写一个名字叫做 has_no_e 的函数，如果给定词汇不含有 e 就返回真，否则为假。</p>
<p>修改一下上一节的程序代码，让它只打印单词表中没有 e 的词汇，并且统计一下这些词汇在总数中的百分比例。</p>
<h3 id="练习-3">练习 3</h3>
<p>写一个名叫 avoids 的函数，接收一个单词和一个禁用字母组合的字符串，如果单词不含有该字符串中的任何字母，就返回真。 修改一下程序代码，提示用户输入一个禁用字母组合的字符串，然后输入不含有这些字母的单词数目。你能找到 5 个被禁用字母组合，排除单词数最少吗？</p>
<h3 id="练习-4">练习 4</h3>
<p>写一个名叫 uses_only 的函数，接收一个单词和一个字母字符串，如果单词仅包含该字符串中的字母，就返回真。你能仅仅用 acefhlo 这几个字母造句子么？或者试试『Hoe alfalfa』?</p>
<h3 id="练习-5">练习 5</h3>
<p>写一个名字叫 uses_all 的函数，接收一个单词和一个必需字母组合的字符串，如果单词对必需字母组合中的字母至少都用了一次就返回真。有多少单词都用到了所有的元音字母 aeiou？aeiouy 的呢？</p>
<h3 id="练习-6">练习 6</h3>
<p>写一个名字叫 is_abecedarian 的函数，如果单词中所有字母都是按照字母表顺序出现就返回真（重叠字母也是允许的）。有多少这样的单词？</p>
<h2 id="93--搜索">9.3  搜索</h2>
<p>刚刚的那些练习都有一些相似之处：都可以用我们在 8.6 学过的搜索来解决。下面是一个最简化的例子：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">has_no_e</span>(<span class="hljs-params">word</span>):
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word:
        <span class="hljs-keyword">if</span> letter == <span class="hljs-string">'e'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>这个 for 循环遍历了单词的所有字母。如果找到了字母 e，就立即返回假；否则就到下一个字母。如果正常退出了循环，意味着我们没找到 e，就返回真。</p>
<p>你可以使用 in 运算符，把这个函数写得更精简，我之所以用一个稍显麻烦的版本，是为了说明搜索模式的逻辑过程。</p>
<p>avoids 是一个更通用版本的 has_no_e 函数的实现，它的结构是一样的：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">avoids</span>(<span class="hljs-params">word, forbidden</span>):
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word:
        <span class="hljs-keyword">if</span> letter <span class="hljs-keyword">in</span> forbidden:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>只要找到了禁用字母就可以立即返回假；如果运行到了循环末尾，就返回真。</p>
<p>uses_only 与之相似，无非是条件与之相反了而已。</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">uses_only</span>(<span class="hljs-params">word, available</span>):
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word:
        <span class="hljs-keyword">if</span> letter <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> available:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>这次不是有一个禁用字母列表，我们这次用一个可用字母列表。如果在单词中发现不在可用字母列表中的，就返回假了。</p>
<p>uses_all 这个函数与之也相似，不过我们转换了单词和字母字符串的角色：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">uses_all</span>(<span class="hljs-params">word, required</span>):
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> required:
        <span class="hljs-keyword">if</span> letter <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> word:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>这次并没有遍历单词中的所有字母，循环遍历了所有指定的字母。如果有任何指定字母没有在单词中出新啊，就返回假。如果你已经像计算机科学家一样思考了，你就应该已经发现了 uses_all 是对之前我们解决过问题的一个实例，你已经写过这个代码了：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">uses_all</span>(<span class="hljs-params">word, required</span>):
    <span class="hljs-keyword">return</span> uses_only(required, word)
</code></pre>
<p>、这就是一种新的程序开发规划模式，就是降低问题的复杂性和难度，还原到以前解决的问题，意思是你发现正在面对的问题是之前解决过的问题的一个实例，就可以用已经存在的方案来解决。</p>
<h2 id="94--用索引循环">9.4  用索引循环</h2>
<p>上面的章节中我写了各种用 for 循环的函数，因为当时只需要字符串中的字符；这就不需要理会索引。</p>
<p>但 is_abecedarian 这个函数中，我们需要对比临近的两个字母，所以用 for 循环就不那么好写了：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_abecedarian</span>(<span class="hljs-params">word</span>):
    previous = word[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word:
        <span class="hljs-keyword">if</span> c &lt; previous:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        previous = c
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>一种很好的替代思路就是使用递归：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_abecedarian</span>(<span class="hljs-params">word</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">if</span> word[<span class="hljs-number">0</span>] &gt; word[<span class="hljs-number">1</span>]:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> is_abecedarian(word[<span class="hljs-number">1</span>:])
</code></pre>
<p>另外一种方法是用 while 循环：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_abecedarian</span>(<span class="hljs-params">word</span>):
    i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(word)-<span class="hljs-number">1</span>:
        <span class="hljs-keyword">if</span> word[i+<span class="hljs-number">1</span>] &lt; word[i]:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        i = i+<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>循环开始于 i 等于 0，然后在 i 等于 len(word)-1 的时候结束。每次通过循环的时候，都对比第 i 个字符（你可以就当是当前字符）与第 i+1 个字符（就当作下一个字符）。</p>
<p>如果下一个字符比当前字符小（字母表排列顺序在当前字符前面），我们就发现这个不符合字母表顺序了，跳出返回假就可以了。</p>
<p>如果一直到循环结尾都没有发现问题，这个词就通过检验了。为了确信循环正确结束了，可以拿单词『flossy』作为例子来试试。单词长度是 6，所以循环终止的时候 i 应该是 4，也就是倒数第二个位置。在最后一次循环中，比较的是倒数第二个和最后一个字母，这正是符合我们设计的。</p>
<p>下面这个是练习 3 的 is_palindrome 的一个版本，使用了两个索引；一个从头开始一直到结尾；另外一个从末尾开始逆序进行。</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_palindrome</span>(<span class="hljs-params">word</span>):
    i = <span class="hljs-number">0</span>
    j = <span class="hljs-built_in">len</span>(word)-<span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> i&lt;j:
        <span class="hljs-keyword">if</span> word[i] != word[j]:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        i = i+<span class="hljs-number">1</span>
        j = j-<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>或者我们可以把问题解构成之前解决过的样式，然后这样写：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_palindrome</span>(<span class="hljs-params">word</span>):
    <span class="hljs-keyword">return</span> is_reverse(word, word)
</code></pre>
<p>这里的 is_reverse 这个函数在第 8 章第 11 节讲过哈。</p>
<h2 id="95--调试">9.5  调试</h2>
<p>测试程序很难的。本章的函数相对来说还算容易测试，因为你可以手动计算来检验结果。即便如此，选择一系列单词然后检测所有可能的错误，可能不仅是做起来困难，甚至都是不可能完成的任务。</p>
<p>比如以 has_no_e 为例，有两种情况用来检查：有 e 的单词应该返回假，不包含 e 的单词要返回真。你自己想出几个这样的单词来检验一下并不难。</p>
<p>在每个分支内，有一些不那么清晰的次级分支。在那些有 e 的单词中，你还要检测单词中的 e 是在开头结尾还是中间位置。你得试试长词、短词，甚至特别短的词，比如空字符串。空字符串是一个典型特例，这个情况很容易被忽视而成为潜伏的隐患。</p>
<p>（译者注：我知道，这段翻译的简直就是 shit，但是没办法，我这会眼睛特别疼，思路不太清楚，另外这几个练习也不是很难，大家很容易自己搞定。）</p>
<p>除了你自己设计的测试案例之外，你也可以用一个单词列表比如 words.txt 之类的来测试一下你的程序。通过扫描一下输出内容，你也许能够发现错误的地方，但一定要小心：你有可能发现某一种特定错误，但忽略了另外一个，比如包含了不应该包含的单词，但很难发现应该包含但遗漏了单词的情况。</p>
<p>总的来说，测试程序能帮助你找到错误地方，但很难找到一系列特别好的测试案例，或者即便你找了很多案例来测试，也不能确保程序就是正确的。一位传说级别的计算机科学家说：</p>
<blockquote>
<p>程序测试可以用来表明 bug 的存在，但永远不能表明 bug 不存在。</p>
<p>— Edsger W. Dijkstra</p>
</blockquote>
<h2 id="96--glossary-术语列表">9.6  Glossary 术语列表</h2>
<p>file object:
A value that represents an open file.</p>
<blockquote>
<p>文件对象：代表了一份打开的文件的值。</p>
</blockquote>
<p>reduction to a previously-solved problem:
A way of solving a problem by expressing it as an instance of a previously-solved problem.</p>
<blockquote>
<p>降低问题的复杂性和难度，还原到以前解决的问题：一种解决问题的方法，把问题表达成过去解决过问题的一个特例。</p>
</blockquote>
<p>special case:
A test case that is a typical or non-obvious (and less likely to be handled correctly).</p>
<blockquote>
<p>特殊案例：很典型或者不明显的测试用的案例，往往都很不容易正确处理。</p>
</blockquote>
<h2 id="97--练习">9.7  练习</h2>
<h3 id="练习-7">练习 7</h3>
<p><a href="http://www.cartalk.com/content/puzzlers" target="_blank">这个问题</a>基于一个谜语，这个谜语在广播节目 Car Talk 上面播放过：</p>
<p>给我一个有三个连续双字母的单词。我会给你一对基本符合的单词，但并不符合。例如， committee 这个单词，C O M M I T E。如果不是有单独的一个 i 在里面，就基本完美了，或者 Mississippi 这个词：M I S I S I P I。如果把这些个 i 都去掉就好了。但有一个词正好是三个重叠字母，而且据我所知这个词可能是唯一一个这样的词。当然有有可能这种单词有五百多个呢，但我只能想到一个。是哪个词呢？写个程序来找一下这个词吧。</p>
<p><a href="http://thinkpython2.com/code/cartalk1.py" target="_blank">样例代码</a></p>
<h3 id="练习-8">练习 8</h3>
<p><a href="http://www.cartalk.com/content/puzzlers" target="_blank">这个</a>又是一个 Car Talk 谜语：</p>
<p>有一天我在高速路上开着车，碰巧看了眼里程表。和大多数里程表一样，是六位数字的，单位是英里。加入我的车跑过 300，000 英里了，看到的结果就是 3-0-0-0-0-0.</p>
<p>我那天看到的很有趣，我看到后四位是回文的；就是说后四位正序和逆序读是一样的。例如 5-4-4-5 就是一个回文数，所以我的里程表可能读书就是 3-1-5-4-4-5.</p>
<p>过了一英里之后，后五位数字是回文的了。举个例子，可能读书就是 3-6-5-4-5-6。又过了一英里，六个数字中间的数字是回文数了。准备好更复杂的了么？又过了一英里，整个六位数都是回文的了！</p>
<p>那么问题俩了：我最开始看到的里程表的度数应该是多少？</p>
<p>写个 Python 程序来检测一下所有的六位数，然后输出一下满足这些要求的数字。 <a href="http://thinkpython2.com/code/cartalk2.py" target="_blank">样例代码</a></p>
<h3 id="练习-9">练习 9</h3>
<p><a href="http://www.cartalk.com/content/puzzlers" target="_blank">这个</a>又是一个 Car Talk 谜语，你可以用搜索来解决：</p>
<p>最近我看忘了妈妈，然后我们发现我的年龄反过来正好是她的年龄。例如，假如他是 73 岁，我就是 37 岁了。我们好奇这种情况发生多少次，但中间叉开了话题，没有想出来这个问题的答案。</p>
<p>我回家之后，我发现到目前位置我们的年龄互为逆序已经是六次了，我还发现如果我们幸运的话过几年又会有一次，如果我们特别幸运，就还会再有一次这样情况。换句话说，就是总共能有八次。那么问题来了：我现在多大了？</p>
<p>写一个 Python 程序，搜索一下这个谜语的解。提示一下：你可能发现字符串的 zfill 方法很有用哦。</p>
<p><a href="http://thinkpython2.com/code/cartalk3.py" target="_blank">样例代码</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter8.html" class="navigation navigation-prev " aria-label="Previous page: 第八章 字符串">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter10.html" class="navigation navigation-next " aria-label="Next page: 第十章 列表">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第九章 案例学习：单词游戏","level":"1.10","depth":1,"next":{"title":"第十章 列表","level":"1.11","depth":1,"path":"chapter10.md","ref":"chapter10.md","articles":[]},"previous":{"title":"第八章 字符串","level":"1.9","depth":1,"path":"chapter8.md","ref":"chapter8.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapter9.md","mtime":"2024-08-23T09:01:53.772Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-23T09:11:00.343Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

