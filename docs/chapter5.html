
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第五章 条件循环 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter6.html" />
    
    
    <link rel="prev" href="chapter4.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="chapter1.html">
            
                <a href="chapter1.html">
            
                    
                    第一章 编程之路
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="chapter2.html">
            
                <a href="chapter2.html">
            
                    
                    第二章 变量，表达式，语句
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="chapter3.html">
            
                <a href="chapter3.html">
            
                    
                    第三章 函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="chapter4.html">
            
                <a href="chapter4.html">
            
                    
                    第四章 案例学习：交互设计
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.6" data-path="chapter5.html">
            
                <a href="chapter5.html">
            
                    
                    第五章 条件循环
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="chapter6.html">
            
                <a href="chapter6.html">
            
                    
                    第六章 有返回值的函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="chapter7.html">
            
                <a href="chapter7.html">
            
                    
                    第七章 迭代
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="chapter8.html">
            
                <a href="chapter8.html">
            
                    
                    第八章 字符串
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="chapter9.html">
            
                <a href="chapter9.html">
            
                    
                    第九章 案例学习：单词游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="chapter10.html">
            
                <a href="chapter10.html">
            
                    
                    第十章 列表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="chapter11.html">
            
                <a href="chapter11.html">
            
                    
                    第十一章 字典
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="chapter12.html">
            
                <a href="chapter12.html">
            
                    
                    第十二章 元组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="chapter13.html">
            
                <a href="chapter13.html">
            
                    
                    第十三章 案例学习：数据结构的选择
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="chapter14.html">
            
                <a href="chapter14.html">
            
                    
                    第十四章 文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="chapter15.html">
            
                <a href="chapter15.html">
            
                    
                    第十五章 类和对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="chapter16.html">
            
                <a href="chapter16.html">
            
                    
                    第十六章 类和函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="chapter17.html">
            
                <a href="chapter17.html">
            
                    
                    第十七章 类和方法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="chapter18.html">
            
                <a href="chapter18.html">
            
                    
                    第十八章 继承
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="chapter19.html">
            
                <a href="chapter19.html">
            
                    
                    第十九章 更多功能
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第五章 条件循环</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第五章--条件循环">第五章  条件循环</h1>
<p>本章的主题是 if 语句，就是条件判断，会对应程序的不同状态来执行不同的代码。但首先我要介绍两种新的运算符：floor（地板除法，舍弃小数位）和 modulus（求模，取余数）</p>
<h2 id="51--地板除和求模">5.1  地板除和求模</h2>
<p>floor 除法，中文有一种翻译是地板除法，挺难听，不过凑活了，运算符是两个右斜杠：//，与传统除法不同，地板除法会把运算结果的小数位舍弃，返回整值。例如，加入一部电影的时间长度是 105 分钟。你可能想要知道这部电影用小时来计算是多长。传统的除法运算如下，会返回一个浮点小数：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>minutes = <span class="hljs-number">105</span> 
<span class="hljs-meta">&gt;&gt;&gt; </span>minutes / <span class="hljs-number">60</span> 
<span class="hljs-number">1.75</span>
</code></pre>
<p>不过一般咱们不写有小数的小时数。地板除法返回的就是整的小时数，舍弃掉小数位：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>minutes = <span class="hljs-number">105</span> 
<span class="hljs-meta">&gt;&gt;&gt; </span>hours = minutes // <span class="hljs-number">60</span> 
<span class="hljs-meta">&gt;&gt;&gt; </span>hours 
<span class="hljs-number">1</span>
</code></pre>
<p>想要知道舍弃那部分的长度，可以用分钟数减去这么一个小时，然后剩下的分钟数就是了：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>remainder = minutes - hours * <span class="hljs-number">60</span> &gt;&gt;&gt; remainder
<span class="hljs-number">45</span>
</code></pre>
<p>另外一个方法就是使用求模运算符了，百分号%就是了，求模运算就是求余数，会把两个数相除然后返回余数。</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>remainder = minutes % <span class="hljs-number">60</span> 
<span class="hljs-meta">&gt;&gt;&gt; </span>remainder 
<span class="hljs-number">45</span>
</code></pre>
<p>求模运算符的作用远不止如此。比如你可以用求模来判断一个数能否被另一个数整除——比如 x%y 如果等于 0 了，那就是意味着 x 能被 y 整除了。</p>
<p>另外你也可以从一个数上取最右侧的一位或多位数字。比如，x%10 就会得出 x 最右边的数字，也就是 x 的个位数字。同样的道理，用 x%100 得到的就是右面两位数字了。</p>
<p>如果你用 Python2 的话，除法是不一样的。在两边都是整形的时候，常规除法运算符/就会进行地板除法，而两边只要有一侧是浮点数就会进行浮点除法。</p>
<h2 id="52--布尔表达式">5.2  布尔表达式</h2>
<p>布尔表达式是一种非对即错的表达式，只有这么两个值，true（真）或者 false（假）。下面的例子都用了双等号运算符，这个运算符会判断两边的值是否相等，相等就是 True，不相等就是 False：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> == <span class="hljs-number">5</span> 
<span class="hljs-literal">True</span> 
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> == <span class="hljs-number">6</span> 
<span class="hljs-literal">False</span>
</code></pre>
<p>True 和 False 都是特殊的值，属于 bool 布尔类型；它们俩不是字符串：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-literal">True</span>) 
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'bool'</span>&gt;  
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-literal">False</span>) 
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'bool'</span>&gt;
</code></pre>
<p>双等号运算符是关系运算符的一种，其他关系运算符如下：</p>
<pre><code class="lang-py">x != y    <span class="hljs-comment"># x is not equal to y          二者相等     </span>
x &gt; y    <span class="hljs-comment"># x is greater than y          前者更大     </span>
x &gt; y    <span class="hljs-comment"># x is greater than y          前者更大     </span>
x &lt; y    <span class="hljs-comment"># x is less than y            前者更小  </span>
x &gt;= y    <span class="hljs-comment"># x is greater than or equal to y 大于等于      </span>
x &gt;= y    <span class="hljs-comment"># x is greater than or equal to y 大于等于      </span>
x &lt;= y    <span class="hljs-comment"># x is less than or equal to y     小于等于</span>
</code></pre>
<p>虽然这些运算符你可能很熟悉了，但一定要注意 Python 里面的符号和数学上的符号有一定区别。常见的错误就是混淆了等号=和双等号==。一定要记住单等号=是一个赋值运算符，而双等号==是关系运算符。另外要注意就是大于等于或者小于等于都是等号放到大于号或者小于号的后面，顺序别弄反。</p>
<h2 id="53--逻辑运算符">5.3  逻辑运算符</h2>
<p>逻辑运算符有三种：且，或以及非。这三种运算符的意思和字面意思差不多。比如 x&gt;0 且 x&lt;10，仅当 x 在 0 到 10 之间的时候才为真。</p>
<p>n%2 == 0 或 n%3 == 0，只要条件有一个成立就是真，就是说这个可以被 2 或 3 整除就行了。</p>
<p>最后说这个非运算，是针对布尔表达式的，非（x&gt;y）为真，那么 x&gt;y 就是假的，意味着 x 小于等于 y。</p>
<p>严格来说，逻辑运算符的运算对象应该必须是布尔表达式，不过 Python 就不太严格。任何非零变量都会被认为是真：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">42</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span> 
<span class="hljs-literal">True</span>
</code></pre>
<p>这种灵活性特别有用，不过有的情况下也容易引起混淆。建议你尽量不要这样用，除非你很熟练了。</p>
<h2 id="54--条件执行">5.4  条件执行</h2>
<p>有用的程序必然要有条件检查判断的功能，根据不同条件要让程序有相应的行为。条件语句就让咱们能够实现这种判断。最简单的就是 if 语句了：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is positive'</span>)
</code></pre>
<p>if 后面的布尔表达式就叫做条件。如果条件为真，随后缩进的语句就运行。如果条件为假，就不运行。</p>
<p>if 语句与函数定义的结构基本一样：一个头部，后面跟着缩进的语句。这样的语句叫做复合语句。</p>
<p>、复合语句中语句体内的语句数量是不限制的，但至少要有一个。有的时候会遇到一个语句体内不放语句的情况，比如空出来用来后续补充。这种情况下，你就可以用 pass 语句，就是啥也不会做的。</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:
    <span class="hljs-keyword">pass</span>          <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> need to handle negative values!</span>
</code></pre>
<h2 id="55-选择执行">5.5 选择执行</h2>
<p>if 语句的第二种形式就是『选择执行』，这种情况下会存在两种备选的语句，根据条件来判断执行哪一个。语法如下所示：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is even'</span>) 
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is odd'</span>)
</code></pre>
<p>I
如果 x 除以 2 的余数为 0，x 就是一个偶数了，程序就会显示对应的信息。如果条件不成立，那就运行第二条语句。这里条件非真即假，只有两个选择。这些选择也叫『分支』，因为在运行流程上产生了不同的分支。</p>
<h2 id="56--链式条件">5.6  链式条件</h2>
<p>有时我们要面对的可能性不只有两种，需要更多的分支。这时候可以使用连锁条件来实现：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> x &lt; y:     
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is less than y'</span>) 
<span class="hljs-keyword">elif</span> x &gt; y:     
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is greater than y'</span>) 
<span class="hljs-keyword">else</span>:     
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x and y are equal'</span>)
</code></pre>
<p>elif 是『else if』的缩写。这回也还是只会有一个分支的语句会被运行。elif 语句的数量是无限制的。如果有 else 语句的话，这个 else 语句必须放到整个条件链的末尾，不过 else 语句并不是必须有的。</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> choice == <span class="hljs-string">'a'</span>:
    draw_a()
<span class="hljs-keyword">elif</span> choice == <span class="hljs-string">'b'</span>:
    draw_b()
<span class="hljs-keyword">elif</span> choice == <span class="hljs-string">'c'</span>:
    draw_c()
</code></pre>
<p>每一个条件都会依次被检查。如果第一个是假，下一个就会被检查，依此类推。如果有一个为真了，相应的分支语句就运行了，这些条件判断的语句就都结束了。如果有一个以上的条件为真，只有先出现的为真的条件所对应的分支语句会运行。</p>
<h2 id="57--嵌套条件">5.7  嵌套条件</h2>
<p>一个条件判断也可以嵌套在另一个条件判断内。上一节的例子可以改写成如下：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> x == y:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x and y are equal'</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">if</span> x &lt; y:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is less than y'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is greater than y'</span>)
</code></pre>
<p>外部的条件判断包含两个分支。第一个分支只有一个简单的语句。第二个分支包含了另外一重条件判断，这个内部条件判断有两个分支。这两个分支都是简单的语句，他们的位置也可以继续放条件判断语句的。</p>
<p>虽然语句的缩进会让代码结构看着比较清晰明显，但嵌套的条件语句读起来还是有点难度。所以建议你如果可以的话，尽量避免使用嵌套的条件判断。</p>
<p>逻辑运算符有时候对简化嵌套条件判断很有用。比如下面这个代码就能改写成更简单的版本:</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; x:
    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">10</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is a positive single-digit number.'</span>)
</code></pre>
<p>上面的例子中，只有两个条件都满足了才会运行 print 语句，所以就用逻辑运算符来实现同样的效果即可：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; x <span class="hljs-keyword">and</span> x &lt; <span class="hljs-number">10</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is a positive single-digit number.'</span>)
</code></pre>
<p>这种条件下，Python 提供了更简洁的表达方法：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; x &lt; <span class="hljs-number">10</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x is a positive single-digit number.'</span>)
</code></pre>
<p>（译者注：Python 的这种友善度远远超过了 C 和 C++，这也是为何我一直建议国内高校用 Python 取代 C++来给本科生和研究生做编程入门课程。）</p>
<h2 id="58--递归运算">5.8  递归运算</h2>
<p>一个函数可以去调用另一个函数；函数来调用自己也是允许的。这就是递归，是程序最神奇的功能之一，现在可能还不好理解为什么，那么来看看下面这个函数为例：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Blastoff!'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(n)
        countdown(n-<span class="hljs-number">1</span>)
</code></pre>
<p>如果 n 为 0 或者负数，程序会输出『Blastoff！』。其他情况下，程序会调用自身来运行，以自身参数 n 减去 1 为参数。如果像下面这样调用这个函数会怎么样？</p>
<pre><code class="lang-Bash">&gt;&gt;&gt; countdown(3)
</code></pre>
<p>开始时候函数参数 n 是 3，大于 0，输出 n 的值 3，然后调用自身，用 n-1 也就是 2 作为参数。。。</p>
<p>接下来的函数参数 n 是 2，大于 0，输出 n 的值 2，然后调用自身，用 n-1 也就是 1 作为参数。。。</p>
<p>再往下去函数参数 n 是 1，大于 0，输出 n 的值 1，然后调用自身，用 n-1 也就是 0 作为参数。。。</p>
<p>最后这次函数参数 n 是 0，等于 0 了，输出『Blastoff！』，然后返回。</p>
<p>n=1 的时候的 countdown 也执行完了，返回。</p>
<p>n=2 的时候的 countdown 也执行完了，返回。</p>
<p>n=3 的时候的 countdown 也执行完了，返回。</p>
<p>（译者注：这时候一定要注意不是输出字符串就完毕了，要返回的每一个层次的函数调用者。这里不理解的话说明对函数调用的过程掌握的不透彻，一定要好好想仔细了。）
接下来你就回到主函数 <strong>main</strong> 里面了。所以总的输出会如下所示：</p>
<pre><code class="lang-Bash">3
2
1
Blastoff!
</code></pre>
<p>调用自身的函数就是递归的；执行这种函数的过程就叫递归运算。</p>
<p>我们再写一个用 print 把一个字符串 s 显示 n 次的例子：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_n</span>(<span class="hljs-params">s, n</span>):
    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>
    <span class="hljs-built_in">print</span>(s)
    print_n(s, n-<span class="hljs-number">1</span>)
s=<span class="hljs-string">"Python is good"</span>
n=<span class="hljs-number">4</span>
print_n(s, n)
</code></pre>
<p>如果 n 小于等于 0 了，返回语句 return 就会终止函数的运行。运行流程立即返回到函数调用者，函数其余各行的代码也都不会执行。</p>
<p>函数其余部分的代码很容易理解：print 一下 s，然后调用自身，用 n-1 做参数来继续运行，这样就额外对 s 进行了 n-1 次的显示。所以输出的行数是 1+（n-1），最终一共有 n 行输出。</p>
<p>上面这种简单的例子，实际上用 for 循环更简单。不过后面我们就会遇到一些用 for 循环不太好写的例子了，这些情况往往用递归更简单，所以早点学习下递归是有好处的。</p>
<h2 id="59--递归函数的栈图">5.9  递归函数的栈图</h2>
<p>在本书的第三章第九节，我们用栈图来表征函数调用过程中程序的状态。同样是这种栈图，将有助于给大家展示递归函数的运行过程。</p>
<p>每次有一个函数被调用的时候，Python 都会创建一个框架来包含这个函数的局部变量和形式参数。对于递归函数来说，可能会在栈中同时生成多层次的框架。</p>
<p>图 5.1 展示了前面样例中 coundown 函数在 n=3 的时候的栈图。</p>
<hr></hr>
<p><img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPythonFigure5.1.png" alt="Figure 5.1: Stack diagram."></img>
Figure 5.1: Stack diagram.</p>
<hr></hr>
<p>栈图的开头依然是主函数 <strong>main</strong>。这里主函数是空的，因为我们没有在主函数里面创建变量或者传递参数进去。</p>
<p>四个 coundown 方框中形式参数 n 的值都是不同的。在栈图底部是 n=0 的时候，也叫基准条件。这时候不再进行递归调用，也就没有更多框架了。</p>
<p>下面练习一下，画一个 print_n 函数的栈图，让 s 为字符串『Hello』，n 为 2。然后写一个函数，名字为 do_n，使用一个操作对象和一个数字 n 作为实际参数，给出一个 n 作为次数来调用这个函数。</p>
<h2 id="510--无穷递归">5.10  无穷递归</h2>
<p>如果一个递归一直都不能到达基准条件，那就会持续不断地进行自我调用，程序也就永远不会终止了。这就叫无穷递归，一般这都不是个好事情哈。下面就是一个无穷递归的最简单的例子：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recurse</span>():
    recurse()
</code></pre>
<p>在大多数的开发环境下，无穷递归的程序并不会真的永远运行下去。Python 会在函数达到允许递归的最大层次后返回一个错误信息：</p>
<pre><code class="lang-Bash">File <span class="hljs-string">"&lt;stdin&gt;"</span>, line 2, <span class="hljs-keyword">in</span> recurse
RuntimeError: Maximum recursion depth exceeded
</code></pre>
<p>这个追踪会我们之前看到的长很多。这种错误出现的时候，栈中都已经有 1000 层递归框架了！</p>
<p>如果你意外写出来一个无穷递归的代码，好好检查一下你的函数，一定要确保有一个基准条件来停止递归调用。如果存在了基准条件，检查一下一定要确保能使之成立。</p>
<h2 id="511--键盘输入">5.11  键盘输入</h2>
<p>目前为止咱们写过的程序还都没有接收过用户的输入。这写程序每次都是做一些同样的事情。</p>
<p>Python 提供了内置的一个函数，名叫 input，这个函数会停止程序运行，等待用户来输入一些内容。用户按下 ESC 或者 Enter 回车键，程序就恢复运行，input 函数就把用户输入的内容作为字符串返回。在 Python2 里面，同样的函数名字不同，叫做 raw_input。</p>
<pre><code class="lang-Bash">&gt;&gt;&gt; text = input()
What are you waiting <span class="hljs-keyword">for</span>?
&gt;&gt;&gt; text
What are you waiting <span class="hljs-keyword">for</span>?
</code></pre>
<p>在用户输入内容之前，最好显示一些提示，来告诉用户需要输入什么内容。input 函数能够把提示内容作为参数：</p>
<pre><code class="lang-Bash">&gt;&gt;&gt; name = input(<span class="hljs-string">'What...is your name?\n'</span>)
What...is your name?
Arthur, King of the Britons!
&gt;&gt;&gt; name
Arthur, King of the Britons!
</code></pre>
<p>提示内容末尾的\n 表示要新建一行，这是一个特殊的字符，表示换行。因为有了换行字符，所以用户输入就跑到了提示内容下面去了。</p>
<p>如果你想要用户来输入一个整形变量，可以把返回的值手动转换一下：</p>
<pre><code class="lang-Bash">&gt;&gt;&gt; prompt = <span class="hljs-string">'What...is the airspeed velocity of an unladen swallow?\n'</span>
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
42
&gt;&gt;&gt; int(speed)
42
</code></pre>
<p>如果用户输入的是其他内容，而不是一串数字，就会得到一个错误了：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>speed = <span class="hljs-built_in">input</span>(prompt)
What...<span class="hljs-keyword">is</span> the airspeed velocity of an unladen swallow?
What do you mean, an African <span class="hljs-keyword">or</span> a European swallow?
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">int</span>(speed) ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>
</code></pre>
<p>稍后我们再来看看如何应对这种错误。</p>
<h2 id="512--调试">5.12  调试</h2>
<p>当语法错误或者运行错误出现的时候，错误信息会包含很多有用的信息，不过信息量太大，太繁杂。最有用的也就下面这两类：</p>
<ul>
<li><p>错误的类型是什么，以及</p>
</li>
<li><p>错误的位置在哪里。</p>
</li>
</ul>
<pre><code class="lang-Bash">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; y = 6
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line 1
    y = 6
    ^
IndentationError: unexpected indent
</code></pre>
<p>这个例子里面，错误的地方是第二行开头用一个空格来缩进了。但这个错误是指向 y 的，这就有点误导了。一般情况下，错误信息都会表示出发现问题的位置，但具体的错误可能是在此位置之前的代码引起的，有的时候甚至是前一行。</p>
<p>同样情况也发生在运行错误的情况下。假设你试着用分贝为单位来计算信噪比。</p>
<p>公式为：
<img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPython%E4%BF%A1%E5%99%AA%E6%AF%94.jpg" alt=""></img></p>
<p>在 Python，你可能像下面这样写：</p>
<pre><code class="lang-py"><span class="hljs-keyword">import</span> math
signal_power = <span class="hljs-number">9</span>
noise_power = <span class="hljs-number">10</span>
ratio = signal_power // noise_power
decibels = <span class="hljs-number">10</span> * math.log10(ratio) <span class="hljs-built_in">print</span>(decibels)
</code></pre>
<p>运行这个程序，你就会得到如下错误信息：</p>
<pre><code class="lang-Bash">Traceback (most recent call last):
    File <span class="hljs-string">"snr.py"</span>, line 5, <span class="hljs-keyword">in</span> ?
        decibels = 10 * math.log10(ratio)
ValueError: math domain error
</code></pre>
<p>这个错误信息提示第五行，但那一行实际上并没有错。要找到真正的错误，就要输出一下 ratio 的值来看一下，结果发现是 0 了。那问题实际是在第四行，应该用浮点除法，结果多打了一个右斜杠，弄成了地板除法，才导致的错误。</p>
<p>所以你得花点时间仔细阅读错误信息，但不要轻易就认为出错信息说的内容都是完全正确可靠的。</p>
<h2 id="513--glossary-术语列表">5.13  Glossary 术语列表</h2>
<p>floor division:
An operator, denoted //, that divides two numbers and rounds down (toward zero) to an integer.</p>
<blockquote>
<p>地板除法：一种运算符，双右斜杠，把两个数相除，舍弃小数位，结果为整形。</p>
</blockquote>
<p>modulus operator:
An operator, denoted with a percent sign (%), that works on integers and returns the remainder when one number is divided by another.</p>
<blockquote>
<p>求模取余：一种运算符，百分号%，对整形起作用，返回两个数字相除的余数。</p>
</blockquote>
<p>boolean expression:
An expression whose value is either True or False.</p>
<blockquote>
<p>布尔表达式：一种值为真或假的表达式。</p>
</blockquote>
<p>relational operator:
One of the operators that compares its operands: ==, !=, &gt;, &lt;, &gt;=, and &lt;=.</p>
<blockquote>
<p>关系运算符：对比运算对象关系的运算符：==相等, !=不等, &gt;大于, &lt;小于, &gt;=大于等于, 以及&lt;=小于等于。</p>
</blockquote>
<p>logical operator:
One of the operators that combines boolean expressions: and, or, and not.</p>
<blockquote>
<p>逻辑运算符：把布尔表达式连接起来的运算符：and 且，or 或，以及 not 非。</p>
</blockquote>
<p>conditional statement:
A statement that controls the flow of execution depending on some condition.</p>
<blockquote>
<p>条件语句：控制运行流程的语句，根据不同条件有不同语句去运行。</p>
</blockquote>
<p>condition:
The boolean expression in a conditional statement that determines which branch runs.</p>
<blockquote>
<p>条件：条件语句所适用的布尔表达式，根据真假来决定运行分支。</p>
</blockquote>
<p>compound statement:
A statement that consists of a header and a body. The header ends with a colon (:). The body is indented relative to the header.</p>
<blockquote>
<p>复合语句：包含头部与语句体的一套语句组合。头部要有冒号做结尾，语句体相对于头部要有一次缩进。</p>
</blockquote>
<p>branch:
One of the alternative sequences of statements in a conditional statement.</p>
<blockquote>
<p>分支：条件语句当中备选的一系列语句。</p>
</blockquote>
<p>chained conditional:
A conditional statement with a series of alternative branches.</p>
<blockquote>
<p>链式条件：一系列可选分支构成的条件语句。</p>
</blockquote>
<p>nested conditional:
A conditional statement that appears in one of the branches of another conditional statement.</p>
<blockquote>
<p>嵌套条件：条件语句分支中继续包含次级条件语句的情况。</p>
</blockquote>
<p>return statement:
A statement that causes a function to end immediately and return to the caller.</p>
<blockquote>
<p>返回语句：一种特殊的语句，功能是终止当前函数，立即跳出到函数调用者。</p>
</blockquote>
<p>recursion:
The process of calling the function that is currently executing.</p>
<blockquote>
<p>递归：函数对自身进行调用的过程。</p>
</blockquote>
<p>base case:
A conditional branch in a recursive function that does not make a recursive call.</p>
<blockquote>
<p>基准条件：递归函数中一个条件分支，要实现终止递归调用。</p>
</blockquote>
<p>infinite recursion:
A recursion that doesn’t have a base case, or never reaches it. Eventually, an infinite recursion causes a runtime error.</p>
<blockquote>
<p>无穷递归：一个没有基准条件的递归，或者永远无法达到基准条件的递归。一般无穷递归总会引起运行错误。</p>
</blockquote>
<h2 id="514--练习">5.14  练习</h2>
<h3 id="练习-1">练习 1</h3>
<p>time 模块提供了一个名字同样叫做 time 的函数，会返回当前格林威治时间的时间戳，就是以某一个时间点作为初始参考值。在 Unix 系统中，时间戳的参考值是 1970 年 1 月 1 号。</p>
<p>（译者注：时间戳就是系统当前时间相对于 1970.1.1 00:00:00 以秒计算的偏移量，时间戳是惟一的。）</p>
<pre><code class="lang-Bash">&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time() 1437746094.5735958
</code></pre>
<p>写一个脚本，读取当前的时间，把这个时间转换以天为单位，剩余部分转换成小时-分钟-秒的形式，加上参考时间以来的天数。</p>
<h3 id="练习-2">练习 2</h3>
<p>费马大定理内容为，a、b、c、n 均为正整数，在 n 大于 2 的情况，下面的等式关系不成立：</p>
<ol>
<li>写一个函数，名叫 check_fermat，这个函数有四个形式参数：a、b、c 以及 n，检查一下费马大定理是否成立，看看在 n 大于 2 的情况下下列等式</li>
</ol>
<p><img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPython%E8%B4%B9%E9%A9%AC.jpg" alt=""></img></p>
<p>是否成立。</p>
<ol>
<li><p>要求程序输出『Holy smokes, Fermat was wrong!』或者『No, that doesn’t work.』</p>
</li>
<li><p>写一个函数来提醒用户要输入 a、b、c 和 n 的值，然后把输入值转换为整形变量，接着用 check_fermat 这个函数来检查他们是否违背了费马大定理。</p>
</li>
</ol>
<h3 id="练习-3">练习 3</h3>
<p>给你三根木棍，你能不能把它们拼成三角形呢？比如一个木棍是 12 英寸长，另外两个是 1 英寸长，这两根短的就不够长，无法拼成三角形了。</p>
<p>（译者注：1 英寸=2.54 厘米）对于任意的三个长度，有一个简单的方法来检测它们能否拼成三角形：</p>
<p>只要三个木棍中有任意一个的长度大于其他两个的和，就拼不成三角形了。必须要任意一个长度都小于两边和才能拼成三角形。（如果两边长等于第三边，就只能组成所谓『退化三角形』了。译者注：实际上这不就成了线段了么？）</p>
<ol>
<li><p>写一个叫做 is_triangle 的函数，用三个整形变量为实际参数，函数根据你输入的值能否拼成三角形来判断输出『Yes』或者『No』。</p>
</li>
<li><p>写一个函数来提示下用户，要输入三遍长度，把它们转换成整形，用 is_triangle 函数来检测这些给定长度的边能否组成三角形。</p>
</li>
</ol>
<h3 id="4---练习-4">4   练习 4</h3>
<p>下面的代码输出会是什么？画一个栈图来表示一下如下例子中程序输出结果时候的状态。</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recurse</span>(<span class="hljs-params">n, s</span>):
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(s)
    <span class="hljs-keyword">else</span>:
        recurse(n-<span class="hljs-number">1</span>, n+s)
recurse(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)
</code></pre>
<ol>
<li><p>recurse(-1, 0)这样的调用函数会有什么效果？</p>
</li>
<li><p>为这个函数写一个文档字符串，解释一下用法（仅此而已）。</p>
</li>
</ol>
<p>接下来的练习用到了第四章我们提到过的 turtle 小乌龟模块。</p>
<h3 id="练习-5">练习 5</h3>
<p>阅读下面的函数，看看你能否弄清楚函数的作用。运行一下试试（参考第四章里面的例子来酌情修改代码）。</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">t, length, n</span>):
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>
    angle = <span class="hljs-number">50</span>
    t.fd(length*n)
    t.lt(angle)
    draw(t, length, n-<span class="hljs-number">1</span>)
    t.rt(<span class="hljs-number">2</span>*angle)
    draw(t, length, n-<span class="hljs-number">1</span>)
    t.lt(angle)
    t.bk(length*n)
</code></pre>
<hr></hr>
<p><img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPythonFigure5.2Koch%20curve.png" alt="Figure 5.2: A Koch curve."></img>
Figure 5.2: A Koch curve.</p>
<hr></hr>
<h3 id="6--练习-6">6  练习 6</h3>
<p>Koch 科赫曲线是一种分形曲线，外观如图 5.2 所示。要画长度为 x 的这种曲线，你要做的步骤如下：</p>
<ol>
<li><p>画一个长度为三分之一 x 的 Koch 曲线。</p>
</li>
<li><p>左转 60 度。</p>
</li>
<li><p>画一个长度为三分之一 x 的 Koch 曲线。</p>
</li>
<li><p>右转 120 度。</p>
</li>
<li><p>画一个长度为三分之一 x 的 Koch 曲线。</p>
</li>
<li><p>左转 60 度。</p>
</li>
<li><p>画一个长度为三分之一 x 的 Koch 曲线。</p>
</li>
</ol>
<p>特例是当 x 小于 3 的时候：这种情况下，你就可以只画一个长度为 x 的直线段。</p>
<ol>
<li><p>写一个叫做 koch 的函数，用一个小乌龟 turtle 以及一个长度 length 做形式参数，用这个小乌龟来画给定长度 length 的 Koch 曲线。</p>
</li>
<li><p>写一个叫做 snowflake 的函数，画三个 Koch 曲线来制作一个雪花的轮廓。<a href="http://thinkpython2.com/code/koch.py" target="_blank">参考代码</a></p>
</li>
<li><p>The Koch curve can be generalized in several ways. See <a href="http://en.wikipedia.org/wiki/Koch_snowflake" target="_blank">here</a> for examples and implement your favorite.</p>
</li>
</ol>
<p>生成 Koch 曲线的方法还有很多。点击 <a href="http://en.wikipedia.org/wiki/Koch_snowflake" target="_blank">这里</a>来查看更多的例子，探索一下看看你喜欢哪个。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter4.html" class="navigation navigation-prev " aria-label="Previous page: 第四章 案例学习：交互设计">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter6.html" class="navigation navigation-next " aria-label="Next page: 第六章 有返回值的函数">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第五章 条件循环","level":"1.6","depth":1,"next":{"title":"第六章 有返回值的函数","level":"1.7","depth":1,"path":"chapter6.md","ref":"chapter6.md","articles":[]},"previous":{"title":"第四章 案例学习：交互设计","level":"1.5","depth":1,"path":"chapter4.md","ref":"chapter4.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapter5.md","mtime":"2024-08-23T09:01:53.770Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-23T09:11:00.343Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

