
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第八章 字符串 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter9.html" />
    
    
    <link rel="prev" href="chapter7.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="chapter1.html">
            
                <a href="chapter1.html">
            
                    
                    第一章 编程之路
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="chapter2.html">
            
                <a href="chapter2.html">
            
                    
                    第二章 变量，表达式，语句
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="chapter3.html">
            
                <a href="chapter3.html">
            
                    
                    第三章 函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="chapter4.html">
            
                <a href="chapter4.html">
            
                    
                    第四章 案例学习：交互设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="chapter5.html">
            
                <a href="chapter5.html">
            
                    
                    第五章 条件循环
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="chapter6.html">
            
                <a href="chapter6.html">
            
                    
                    第六章 有返回值的函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="chapter7.html">
            
                <a href="chapter7.html">
            
                    
                    第七章 迭代
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.9" data-path="chapter8.html">
            
                <a href="chapter8.html">
            
                    
                    第八章 字符串
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="chapter9.html">
            
                <a href="chapter9.html">
            
                    
                    第九章 案例学习：单词游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="chapter10.html">
            
                <a href="chapter10.html">
            
                    
                    第十章 列表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="chapter11.html">
            
                <a href="chapter11.html">
            
                    
                    第十一章 字典
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="chapter12.html">
            
                <a href="chapter12.html">
            
                    
                    第十二章 元组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="chapter13.html">
            
                <a href="chapter13.html">
            
                    
                    第十三章 案例学习：数据结构的选择
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="chapter14.html">
            
                <a href="chapter14.html">
            
                    
                    第十四章 文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="chapter15.html">
            
                <a href="chapter15.html">
            
                    
                    第十五章 类和对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="chapter16.html">
            
                <a href="chapter16.html">
            
                    
                    第十六章 类和函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="chapter17.html">
            
                <a href="chapter17.html">
            
                    
                    第十七章 类和方法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="chapter18.html">
            
                <a href="chapter18.html">
            
                    
                    第十八章 继承
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="chapter19.html">
            
                <a href="chapter19.html">
            
                    
                    第十九章 更多功能
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第八章 字符串</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第八章--字符串">第八章  字符串</h1>
<p>字符串和整形、浮点数以及布尔值很不一样。一个字符串是一个序列，意味着是对其他值的有序排列。在本章你将学到如何读取字符串中的字符，你还会学到一些字符串相关的方法。</p>
<h2 id="81--字符串是序列">8.1  字符串是序列</h2>
<p>字符串就是一串有序的字符。你可以通过方括号操作符，每次去访问字符串中的一个字符：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fruit = <span class="hljs-string">'banana'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>letter = fruit[<span class="hljs-number">1</span>]
</code></pre>
<p>第二个语句选择了 fruit 这个字符串的序号为 1 的字符，并把这个字符赋值给了 letter 这个变量。</p>
<p>（译者注：思考一下这里的 letter 是一个什么类型的变量。）</p>
<p>方括号内的内容叫做索引。索引指示了你所指定的字符串中字符的位置（就跟名字差不多）。</p>
<p>但你可能发现得到的结果和你预期的有点不一样：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>letter
<span class="hljs-string">'a'</span>
</code></pre>
<p>大多数人都认为 banana 的第『1』个字符应该是 b，而不是 a。但对于计算机科学家来说，索引是字符串从头的偏移量，所以真正的首字母偏移量应该是 0.</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>letter = fruit[<span class="hljs-number">0</span>]&gt;&gt;&gt; letter
<span class="hljs-string">'b'</span>
</code></pre>
<p>所以 b 就是字符串 banana 的第『0』个字符，而 a 是第『1』个，n 就是第『2』个了。</p>
<p>你可以在方括号内的索引中使用变量和表达式：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>i = <span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>fruit[i]
<span class="hljs-string">'a'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>fruit[i+<span class="hljs-number">1</span>]
<span class="hljs-string">'n'</span>
</code></pre>
<p>但要注意的事，索引的值必须是整形的。否则你就会遇到类型错误了：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>letter = fruit[<span class="hljs-number">1.5</span>]
TypeError: string indices must be integers
</code></pre>
<h2 id="82--len-长度">8.2  len 长度</h2>
<p>len 是一个内置函数，会返回一个字符串中字符的长度：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fruit = <span class="hljs-string">'banana'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(fruit) <span class="hljs-number">6</span>
</code></pre>
<p>要得到一个字符串的最后一个字符，你可能会想到去利用 len 函数：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>length = <span class="hljs-built_in">len</span>(fruit)
<span class="hljs-meta">&gt;&gt;&gt; </span>last = fruit[length]
IndexError: string index out of <span class="hljs-built_in">range</span>
</code></pre>
<p>出现索引错误的原因就是 banana 这个字符串在第『6』个位置是没有字母的。因为我们从 0 开始数，所以这一共 6 个字母的顺序是 0 到 5 号。因此要得到最后一次字符，你需要在字符串长度的基础上减去 1 才行：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>last = fruit[length-<span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>last
<span class="hljs-string">'a'</span>
</code></pre>
<p>或者你也可以用负数索引，意思就是从字符串的末尾向前数几位。fruit[-1]这个表达式给你最后一个字符，fruit[-2]给出倒数第二个，依此类推。</p>
<h2 id="83--用-for-循环遍历字符串">8.3  用 for 循环遍历字符串</h2>
<p>很多计算过程都需要每次从一个字符串中拿一个字符。一般都是从头开始，依次得到每个字符，然后做点处理，然后一直到末尾。这种处理模式叫遍历。写一个遍历可以使用 while 循环：</p>
<pre><code class="lang-py">index = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(fruit):
    letter = fruit[index]
    <span class="hljs-built_in">print</span>(letter)
    index = index + <span class="hljs-number">1</span>
</code></pre>
<p>这个循环遍历了整个字符串，然后它再把买一个字符显示在一行上面。循环条件是 index 这个变量小于字符串 fruit 的长度，所以当 index 与字符串长度相等的时候，条件就不成立了，循环体就不运行了。最后一个字符被获取的时候，index 正好是 len(fruit)-1，这就已经是该字符串的最后一个字符了。</p>
<p>下面就练习一下了，写一个函数，接收一个字符串做参数，然后倒序显示每一个字符，每行显示一个。</p>
<p>另外一种遍历的方法就是 for 循环了：</p>
<pre><code class="lang-py"><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> fruit:
    <span class="hljs-built_in">print</span>(letter)
</code></pre>
<p>每次循环之后，字符串中的下一个字符都会赋值给变量 letter。循环在进行到没有字符剩余的时候就停止了。</p>
<p>下面的例子展示了如何使用级联（字符串加法）以及一个 for 循环来生成一个简单的序列（用字母表顺序）。</p>
<p>在 Robert McCloskey 的一本名叫《Make Way for Ducklings》的书中，小鸭子的名字依次为：Jack, Kack, Lack, Mack, Nack, Ouack, Pack, 和 Quack。下面这个循环会依次输出他们的名字：</p>
<pre><code class="lang-py">prefixes = <span class="hljs-string">'JKLMNOPQ'</span>
suffix = <span class="hljs-string">'ack'</span>
<span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> prefixes:
    <span class="hljs-built_in">print</span>(letter + suffix)
</code></pre>
<p>输出结果如下：</p>
<pre><code class="lang-py">Jack Kack Lack Mack Nack Oack Pack Qack
</code></pre>
<p>当然了，有点不准确的地方，因为有“Ouack”和 “Quack”两处拼写错了。做个练习，修改一下程序，改正这个错误。</p>
<h2 id="84--字符串切片">8.4  字符串切片</h2>
<p>字符串的一段叫做切片。从字符串中选择一部分做切片，与选择一个字符有些相似：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'Monty Python'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]
<span class="hljs-string">'Monty'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s[<span class="hljs-number">6</span>:<span class="hljs-number">12</span>]
<span class="hljs-string">'Python'</span>
</code></pre>
<p>[n:m]这种操作符，会返回字符串中从第『n』个到第『m』个的字符，包含开头的第『n』个，但不包含末尾的第『m』个。这个设计可能有点违背直觉，但可能有助于想象这个切片在字符串中的方向，如图 8.1。</p>
<hr></hr>
<p><img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPythonFigure8.1.png" alt="Figure 8.1"></img>
Figure 8.1: Slice indices.</p>
<hr></hr>
<p>如果你忽略了第一个索引（就是冒号前面的那个），切片会默认从字符串头部开始。如果你忽略了第二个索引，切片会一直包含到最后一位：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fruit = <span class="hljs-string">'banana'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>fruit[:<span class="hljs-number">3</span>]
<span class="hljs-string">'ban'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>fruit[<span class="hljs-number">3</span>:]
<span class="hljs-string">'ana'</span>
</code></pre>
<p>如果两个索引相等，得到的就是空字符串了，用两个单引号来表示：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fruit = <span class="hljs-string">'banana'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>fruit[<span class="hljs-number">3</span>:<span class="hljs-number">3</span>]
<span class="hljs-string">''</span>
</code></pre>
<p>空字符串不包含字符，长度为 0，除此之外，都与其他字符串是一样的。</p>
<p>那么来练习一下，你觉得 fruit[:]这个是什么意思？在程序中试试吧。</p>
<h2 id="85--字符串不可修改">8.5  字符串不可修改</h2>
<p>大家总是有可能想试试把方括号在赋值表达式的等号左侧，试图去更改字符串中的某一个字符。比如：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>greeting = <span class="hljs-string">'Hello, world!'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>greeting[<span class="hljs-number">0</span>] = <span class="hljs-string">'J'</span>
TypeError: <span class="hljs-string">'str'</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment
</code></pre>
<p>『object』是对象的意思，这里指的是字符串类 string，然后『item』是指你试图赋值的字符串中的字符。目前来说，一个对象就跟一个值差不多，但后续在第十章第十节我们再对这个定义进行详细讨论。</p>
<p>产生上述错误的原因是字符串是不能被修改的，这意味着你不能对一个已经存在的字符串进行任何改动。你顶多也就能建立一个新字符串，新字符串可以基于旧字符串进行一些改动。</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>greeting = <span class="hljs-string">'Hello, world!'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>new_greeting = <span class="hljs-string">'J'</span> + greeting[<span class="hljs-number">1</span>:]
<span class="hljs-meta">&gt;&gt;&gt; </span>new_greeting
<span class="hljs-string">'Jello, world!'</span>
</code></pre>
<p>上面的例子中，对 greeting 这个字符串进行了切片，然后添加了一个新的首字母过去。这并不会对原始字符串有任何影响。（译者注：也就是 greeting 这个字符串的值依然是原来的值，是不可改变的。）</p>
<h2 id="86--搜索">8.6  搜索</h2>
<p>下面这个函数是干啥的？</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">word, letter</span>):
    index = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(word):
        <span class="hljs-keyword">if</span> word[index] == letter:
            <span class="hljs-keyword">return</span> index
        index = index + <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
</code></pre>
<p>简单来说，find 函数，也就是查找，是方括号操作符[]的逆运算。方括号是之道索引然后提取对应的字符，而查找函数是选定一个字符去查找这个字符出现的索引位置。如果字符没有被报道，函数就返回-1。</p>
<p>这是我们见过的第一个返回语句位于循环体内的例子。如果 word[index]等于 letter，函数就跳出循环立刻返回。如果字符在字符串里面没出现，程序正常退出循环并且返回-1。</p>
<p>这种计算-遍历一个序列然后返回我们要找的东西的模式就叫做搜索了。</p>
<p>做个练习，修改一下 find 函数，加入第三个参数，这个参数为查找开始的字符串位置。</p>
<h2 id="87--循环和计数">8.7  循环和计数</h2>
<p>下面这个程序计算了字母 a 在一个字符串中出现的次数：</p>
<pre><code class="lang-py">word = <span class="hljs-string">'banana'</span>
count = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word:
    <span class="hljs-keyword">if</span> letter == <span class="hljs-string">'a'</span>:
    count = count + <span class="hljs-number">1</span>
    <span class="hljs-built_in">print</span>(count)
</code></pre>
<p>这一程序展示了另外一种计算模式，叫做计数。变量 count 被初始化为 0，然后每次在字符串中找到一个 a，就让 count 加 1.当循环退出的时候，count 就包含了 a 出现的总次数。</p>
<p>做个练习，把上面的代码封装进一个名叫 count 的函数中，泛化一下，一遍让他接收任何字符串和字幕作为参数。</p>
<p>然后再重写一下这个函数，这次不再让它遍历整个字符串，而使用上一节中练习的三参数版本的 find 函数。</p>
<h2 id="88--字符串方法">8.8  字符串方法</h2>
<p>字符串提供了一些方法，这些方法能够进行很多有用的操作。方法和函数有些类似，也接收参数然后返回一个值，但语法稍微不同。比如，upper 这个方法就读取一个字符串，返回一个全部为大写字母的新字符串。</p>
<p>与函数的 upper(word)语法不同，方法的语法是 word.upper()。</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>word = <span class="hljs-string">'banana'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>new_word = word.upper()
<span class="hljs-meta">&gt;&gt;&gt; </span>new_word 
<span class="hljs-string">'BANANA'</span>
</code></pre>
<p>这种用点号分隔的方法表明了使用的方法名字为 upper，使用这个方法的字符串的名字为 word。后面括号里面是空白的，表示这个方法不接收参数。</p>
<p>A method call is called an invocation;方法的调用被叫做——调用（译者注：中文都混淆成调用，英文里面 invocation 和 invoke 都有祈祷的意思，和 call 有显著的意义差别，但中文都混淆成调用，这种例子不胜枚举，所以大家尽量多读原版作品。）；在这里，我们就说调用了 word 的 upper 方法。</p>
<p>结果我们发现 string 有一个方法叫做 find，跟我们写过的函数 find 有惊人的相似：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>word = <span class="hljs-string">'banana'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>index = word.find(<span class="hljs-string">'a'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>index
<span class="hljs-number">1</span>
</code></pre>
<p>在这里我们调用了 word 的 find 方法，然后给定了我们要找的字母 a 作为一个参数。</p>
<p>实际上，这个 find 方法比我们的 find 函数功能更通用；它不仅能查找字符，还能查找字符串：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>word.find(<span class="hljs-string">'na'</span>)
<span class="hljs-number">2</span>
</code></pre>
<p>默认情况下 find 方法从字符串的开头来查找，不过可以给它一个第二个参数，让它从指定位置查找：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>word.find(<span class="hljs-string">'na'</span>, <span class="hljs-number">3</span>)
<span class="hljs-number">4</span>
</code></pre>
<p>这是一个可选参数的例子；find 方法还能接收第三个参数，可以指定查找终止的位置：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">'bob'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>name.find(<span class="hljs-string">'b'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
-<span class="hljs-number">1</span>
</code></pre>
<p>这个搜索失败了，因为 b 并没有在索引 1 到 2 且不包括 2 的字符中间出现。搜索到指定的第三个变量作为索引的位置，但不包括该位置，这就让 find 方法与切片操作符相一致。</p>
<h2 id="89--运算符-in">8.9  运算符 in</h2>
<p>in 这个词在字符串操作中是一个布尔操作符，它读取两个字符串，如果前者的字符串为后者所包含，就返回真，否则为假：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'a'</span> <span class="hljs-keyword">in</span> <span class="hljs-string">'banana'</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'seed'</span> <span class="hljs-keyword">in</span> <span class="hljs-string">'banana'</span>
<span class="hljs-literal">False</span>
</code></pre>
<p>举个例子，下面的函数显示所有同时在 word1 和 word2 当中出现的字母：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">in_both</span>(<span class="hljs-params">word1, word2</span>):
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word1:
        <span class="hljs-keyword">if</span> letter <span class="hljs-keyword">in</span> word2:
            <span class="hljs-built_in">print</span>(letter)
</code></pre>
<p>选好变量名的话，Python 有时候读起来就跟英语差不多。你读一下这个循环，就能发现，『对第一个 word 当中的每一个字母 letter，如果这个字母也在第二个 word 当中出现，就输出这个字母 letter。』</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>in_both(<span class="hljs-string">'apples'</span>, <span class="hljs-string">'oranges'</span>)
a e s
</code></pre>
<h2 id="810--字符串比较">8.10  字符串比较</h2>
<p>关系运算符对于字符串来说也可用。比如可以看看两个字符串是不是相等：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> word == <span class="hljs-string">'banana'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'All right, bananas.'</span>)
</code></pre>
<p>其他的关系运算符可以来把字符串按照字母表顺序排列：</p>
<pre><code class="lang-py"><span class="hljs-keyword">if</span> word &lt; <span class="hljs-string">'banana'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Your word, '</span> + word + <span class="hljs-string">', comes before banana.'</span>)
<span class="hljs-keyword">elif</span> word &gt; <span class="hljs-string">'banana'</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Your word, '</span> + word + <span class="hljs-string">', comes after banana.'</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'All right, bananas.'</span>)
</code></pre>
<p>Python 对大小写字母的处理与人类常规思路不同。所有大写字母都在小写字母之前，所以顺序上应该是：Your word，然后是 Pineapple，然后才是 banana。</p>
<p>一个解决这个问题的普遍方法是把字符串转换为标准格式，比如都转成小写的，然后再进行比较。一定要记得哈，以免你遇到一个用 Pineapple 武装着自己的家伙的时候手足无措。</p>
<h2 id="811--调试">8.11  调试</h2>
<p>使用索引来遍历一个序列中的值的时候，弄清楚遍历的开头和结尾很不容易。下面这个函数用来对比两个单词，如果一个是另一个的倒序就返回真，但这个函数代码中有两处错误：</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_reverse</span>(<span class="hljs-params">word1, word2</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word1) != <span class="hljs-built_in">len</span>(word2):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    i = <span class="hljs-number">0</span>
    j = <span class="hljs-built_in">len</span>(word2)
    <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:
        <span class="hljs-keyword">if</span> word1[i] != word2[j]:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        i = i+<span class="hljs-number">1</span>
        j = j-<span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<p>第一个 if 语句是检查两个词的长度是否一样。如果不一样长，当场就返回假。对函数其余部分，我们假设两个单词一样长。这里用到了守卫模式，在第 6 章第 8 节我们提到过。</p>
<p>i 和 j 都是索引：i 从头到尾遍历单词 word1，而 j 逆向遍历单词 word2.如果我们发现两个字母不匹配，就可以立即返回假。如果经过整个循环，所有字母都匹配，就返回真。</p>
<p>如果我们用这个函数来处理单词『pots』和『stop』，我们希望函数返回真，但得到的却是索引错误：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>is_reverse(<span class="hljs-string">'pots'</span>, <span class="hljs-string">'stop'</span>)
 ...   File <span class="hljs-string">"reverse.py"</span>, line <span class="hljs-number">15</span>, <span class="hljs-keyword">in</span> is_reverse     <span class="hljs-keyword">if</span> word1[i] != word2[j]: IndexError: string index out of <span class="hljs-built_in">range</span>
</code></pre>
<p>为了改正这个错误，第一步就是在出错的那行之前先输出索引的值。</p>
<pre><code class="lang-py"><span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:
    <span class="hljs-built_in">print</span>(i, j)        <span class="hljs-comment"># print here</span>
<span class="hljs-keyword">if</span> word1[i] != word2[j]:
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    i = i+<span class="hljs-number">1</span>
    j = j-<span class="hljs-number">1</span>
</code></pre>
<p>然后我再次运行函数，得到更多信息了：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>is_reverse(<span class="hljs-string">'pots'</span>, <span class="hljs-string">'stop'</span>)
<span class="hljs-number">0</span> <span class="hljs-number">4</span>
<span class="hljs-meta">... </span>IndexError: string index out of <span class="hljs-built_in">range</span>
</code></pre>
<p>第一次循环完毕的时候，j 的值是 4，这超出了『pots』这个字符串的范围了（译者注：应该是 0-3）。最后一个索引应该是 3，所以 j 的初始值应该是 len(word2)-1。</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>is_reverse(<span class="hljs-string">'pots'</span>, <span class="hljs-string">'stop'</span>)
<span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>
<span class="hljs-literal">True</span>
</code></pre>
<p>这次我们得到了正确的结果，但似乎循环只走了三次，这有点奇怪。为了弄明白带到怎么回事，我们可以画一个状态图。在第一次迭代的过程中，is_reverse 的框架如图 8.2 所示。</p>
<hr></hr>
<p><img src="http://7xnq2o.com1.z0.glb.clouddn.com/ThinkPythonFigure8.2.png" alt="Figure 8.2"></img>
Figure 8.2: State diagram.</p>
<hr></hr>
<p>我通过设置变量框架中添加虚线表明，i 和 j 的值显示在人物 word1and word2 拿许可证。</p>
<p>从这个图上运行的程序，文件，更改这些值 I 和 J 在每一次迭代过程。发现并解决此函数中的二次错误。</p>
<h2 id="812--glossary-术语列表">8.12  Glossary 术语列表</h2>
<p>object:
Something a variable can refer to. For now, you can use “object” and “value” interchangeably.</p>
<blockquote>
<p>对象：一个值能够指代的东西。目前为止，你可以把对象和值暂且作为一码事来理解。</p>
</blockquote>
<p>sequence:
An ordered collection of values where each value is identified by an integer index.</p>
<blockquote>
<p>序列：一系列值的有序排列，每一个值都有一个唯一的整数序号。</p>
</blockquote>
<p>item:
One of the values in a sequence.</p>
<blockquote>
<p>元素：一列数值序列当中的一个值。</p>
</blockquote>
<p>index:
An integer value used to select an item in a sequence, such as a character in a string. In Python indices start from 0.</p>
<blockquote>
<p>索引：一个整数值，用来指代一个序列中的特定一个元素，比如在字符串里面就指代一个字符。在 Python 里面索引从 0 开始计数。</p>
</blockquote>
<p>slice:
A part of a string specified by a range of indices.</p>
<blockquote>
<p>切片：字符串的一部分，通过一个索引区间来取得。</p>
</blockquote>
<p>empty string:
A string with no characters and length 0, represented by two quotation marks.</p>
<blockquote>
<p>空字符串：没有字符的字符串，长度为 0，用两个单引号表示。</p>
</blockquote>
<p>immutable:
The property of a sequence whose items cannot be changed.</p>
<blockquote>
<p>不可更改：一个序列中所有元素不能被改变的性质。</p>
</blockquote>
<p>traverse:
To iterate through the items in a sequence, performing a similar operation on each.</p>
<blockquote>
<p>遍历：在一个序列中依次对每一个元素进行某种相似运算的过程。</p>
</blockquote>
<p>search:
A pattern of traversal that stops when it finds what it is looking for.</p>
<blockquote>
<p>搜索：一种遍历的模式，找到要找的内容的时候就停止。</p>
</blockquote>
<p>counter:
A variable used to count something, usually initialized to zero and then incremented.</p>
<blockquote>
<p>计数：一种用来统计某种东西数量的变量，一般初始化为 0，然后逐次递增。</p>
</blockquote>
<p>invocation:
A statement that calls a method.</p>
<blockquote>
<p>方法调用：调用方法的语句。</p>
</blockquote>
<p>optional argument:
A function or method argument that is not required.</p>
<blockquote>
<p>可选参数：一个函数或者方法中有一些参数是可选的，非必需的。</p>
</blockquote>
<h2 id="813--练习">8.13  练习</h2>
<h3 id="练习-1">练习 1</h3>
<p>阅读 <a href="http://docs.python.org/2/library/stdtypes.html#string-methods" target="_blank">这里</a>关于字符串的文档。你也许会想要试试其中一些方法，来确保你理解它们的意义。比如 strip 和 replace 都特别有用。</p>
<p>文档的语法有可能不太好理解。比如在 find 这个方法中，方括号表示了可选参数。所以 sub 是必须的参数，但 start 是可选的，如果你包含了 start，end 就是可选的了。</p>
<h3 id="练习-2">练习 2</h3>
<p>字符串有个方法叫 count，与咱们在 8.7 中写的 count 函数很相似。 阅读一下这个方法的文档，然后写一个调用这个方法的代码，统计一下 banana 这个单词中 a 出现的次数 。</p>
<h3 id="练习-3">练习 3</h3>
<p>字符串切片可以使用第三个索引，作为步长来使用；步长的意思就是取字符的间距。一个步长为 2 的意思就是每隔一个取一个字符；3 的意思就是每次取第三个，以此类推。</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span>fruit = <span class="hljs-string">'banana'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>fruit[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]
<span class="hljs-string">'bnn'</span>
</code></pre>
<p>步长如果为-1，意思就是倒序读取字符串，所以[::-1]这个切片就会生成一个逆序的字符串了。</p>
<p>使用这个方法把练习三当中的 is_palindrome 写成一个一行代码的版本。</p>
<h3 id="练习-4">练习 4</h3>
<p>下面这些函数都试图检查一个字符串是不是包含小写字母，但他们当中肯定有些是错的。描述一下每个函数真正的行为（假设参数是一个字符串）。</p>
<pre><code class="lang-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">any_lowercase1</span>(<span class="hljs-params">s</span>):
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> c.islower():
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">any_lowercase2</span>(<span class="hljs-params">s</span>):
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> <span class="hljs-string">'c'</span>.islower():
            <span class="hljs-keyword">return</span> <span class="hljs-string">'True'</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'False'</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">any_lowercase3</span>(<span class="hljs-params">s</span>):
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:
        flag = c.islower()
        <span class="hljs-keyword">return</span> flag
<span class="hljs-keyword">def</span> <span class="hljs-title function_">any_lowercase4</span>(<span class="hljs-params">s</span>):
    flag = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:
            flag = flag <span class="hljs-keyword">or</span> c.islower()
            <span class="hljs-keyword">return</span> flag
<span class="hljs-keyword">def</span> <span class="hljs-title function_">any_lowercase5</span>(<span class="hljs-params">s</span>):
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c.islower():
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<h3 id="练习-5">练习 5</h3>
<p>凯撒密码是一种简单的加密方法，用的方法是把每个字母进行特定数量的移位。对一个字母移位就是把它根据字母表的顺序来增减对应，如果到末尾位数不够就从开头算剩余的位数，『A』移位 3 就是『D』，而『Z』移位 1 就是『A』了。</p>
<p>要对一个词进行移位，要把每个字母都移动同样的数量。比如『cheer』这个单词移位 7 就是『jolly』，而『melon』移位-10 就是『cubed』。在电影《2001 太空漫游》中，飞船的电脑叫 HAL，就是 IBM 移位-1。</p>
<p>写一个名叫 rotate_word 的函数，接收一个字符串和一个整形为参数，返回将源字符串移位该整数位得到的新字符串。</p>
<p>你也许会用得上内置函数 ord，它把字符转换成数值代码，然后还有个 chr 是用来把数值代码转换成字符。字母表中的字母都被编译成跟字母表中同样的顺序了，所以如下所示：</p>
<pre><code class="lang-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">ord</span>(<span class="hljs-string">'c'</span>) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">'a'</span>)
<span class="hljs-number">2</span>
</code></pre>
<p>c 是字母表中的第『2』个（译者注：从 0 开始数哈）的位置，所以上述结果是 2。但注意：大写字母的数值代码是和小写的不一样的。</p>
<p>网上很多有冒犯意义的玩笑都是用 ROT13 加密的，也就是移位 13 的凯撒密码。如果你不太介意，找一下这些密码解密一下吧。<a href="http://thinkpython2.com/code/rotate.py" target="_blank">样例代码</a>.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter7.html" class="navigation navigation-prev " aria-label="Previous page: 第七章 迭代">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter9.html" class="navigation navigation-next " aria-label="Next page: 第九章 案例学习：单词游戏">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第八章 字符串","level":"1.9","depth":1,"next":{"title":"第九章 案例学习：单词游戏","level":"1.10","depth":1,"path":"chapter9.md","ref":"chapter9.md","articles":[]},"previous":{"title":"第七章 迭代","level":"1.8","depth":1,"path":"chapter7.md","ref":"chapter7.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapter8.md","mtime":"2024-08-23T09:01:53.771Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-23T09:11:00.343Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

